<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiny Toon Duel</title>
<link rel="stylesheet" href="styles.css">
	</head>
	<body>
	  <div id="app">
    <div id="canvasWrap">
	      <canvas id="scene"></canvas>
	      <div id="hud" data-mode="menu">
	        <button id="visualToggle" type="button" aria-label="Toggle visuals">
	          Visuals <span class="pill" id="visualToggleLabel">GLTF</span>
	        </button>
	        <div id="playerPanels"></div>

        <div id="timerPanel">
          <div id="timer">TIME: 01:45</div>
          <div id="roundPips">
            <span class="pip"></span><span class="pip"></span><span class="pip"></span><span class="pip"></span><span class="pip"></span>
          </div>
        </div>

	        <div id="bottomBar">
		          <div id="controls" class="panel">WASD Move · Mouse Aim · Click Fire · 1-5 Switch · E Kick · Space Dash · R Reload · G Grenade · O Settings · P Pause</div>
	          <div id="dash">Dash<div class="cooldown"></div></div>
	        </div>

        <div id="banner">ROUND 1 · FIGHT!</div>
        <div id="suddenDeath">SUDDEN DEATH</div>

	        <div id="menuOverlay" class="overlay visible">
          <a href="../../index.html" class="home-btn" id="home-btn" title="Back to Hub">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
              <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
              <polyline points="9,22 9,12 15,12 15,22"/>
            </svg>
            <span>Hub</span>
          </a>
	          <h1>Tiny Toon Duel</h1>
	          <div class="subtitle" id="modeSubtitle">Fast, tight 1v1 duel in a tiny arena.</div>
	          <div class="modeSelect">
	            <button class="modeBtn" data-mode="duel">1v1 Duel</button>
	            <button class="modeBtn" data-mode="deathmatch">4-Player FFA</button>
	          </div>
	          <div class="rules" id="modeRules">Best of 5 · 1:45 time limit · Barrels hurt both players</div>
	          <div class="difficultySelect" id="difficultySelect">
	            <div class="difficultyLabel" id="difficultyLabel">AI Difficulty</div>
	            <div class="difficultyButtons">
	              <button class="difficultyBtn" data-diff="easy" type="button">Easy</button>
	              <button class="difficultyBtn" data-diff="normal" type="button">Normal</button>
	              <button class="difficultyBtn" data-diff="hard" type="button">Hard</button>
	            </div>
	          </div>
	          <div class="statLine">Press <strong>Enter</strong> to Start</div>
	          <div id="bestTime">Best win time: --</div>
	        </div>

        <div id="pauseOverlay" class="overlay">
          <div class="pause-panel">
            <h1>PAUSED</h1>
            <div class="pause-menu">
              <button class="pause-btn" id="btnResume" type="button">Resume</button>
              <button class="pause-btn" id="btnPauseSettings" type="button">Settings</button>
              <button class="pause-btn" id="btnControls" type="button">Controls</button>
              <button class="pause-btn" id="btnMainMenu" type="button">Main Menu</button>
              <button class="pause-btn danger" id="btnHub" type="button">Return to Hub</button>
            </div>
          </div>
        </div>

        <div id="matchOverlay" class="overlay">
          <div class="match-panel">
            <h1 id="matchTitle">Player 1 Wins!</h1>
            <div class="subtitle" id="matchStats">Match time: 00:00</div>
            <div id="matchStatsDetail"></div>
            <div id="bestTimeEnd">Best win time: --</div>
            <div class="match-menu">
              <button class="pause-btn" id="btnRematch" type="button">Rematch</button>
              <button class="pause-btn" id="btnMatchMainMenu" type="button">Main Menu</button>
              <button class="pause-btn danger" id="btnMatchHub" type="button">Return to Hub</button>
            </div>
          </div>
        </div>

        <div id="controlsOverlay">
          <div class="controls-panel">
            <div class="settings-title">Controls</div>
            <div class="controls-list" id="controlsList"></div>
            <div class="controls-actions">
              <button class="pause-btn" id="btnResetControls" type="button">Reset to Defaults</button>
              <button class="settings-close" id="controlsClose" type="button">Close</button>
            </div>
          </div>
        </div>

        <div id="leaderboardOverlay" class="overlay">
          <h1>Leaderboard</h1>
          <div class="leaderboardList" id="leaderboardList"></div>
          <div class="rules">Hold Tab to view</div>
        </div>

        <div id="nearMissFlash"></div>
        <div id="hitFlash"></div>
        <div id="vignette"></div>
        <div id="lowHpVignette"></div>
        <div id="dramaticOverlay"></div>
        <div id="popups"></div>
        <div id="killCamText">ELIMINATED</div>
        
        <div id="settingsOverlay">
          <div class="settings-panel">
            <div class="settings-title">Settings</div>
            <div class="settings-group">
              <div class="setting-row">
                <span class="setting-label">Master Volume</span>
                <input type="range" class="setting-slider" id="settingMasterVol" min="0" max="100" value="70">
              </div>
              <div class="setting-row">
                <span class="setting-label">SFX Volume</span>
                <input type="range" class="setting-slider" id="settingSfxVol" min="0" max="100" value="80">
              </div>
              <div class="setting-row">
                <span class="setting-label">Show Damage Numbers</span>
                <button class="setting-toggle active" id="settingDamageNumbers" type="button"></button>
              </div>
              <div class="setting-row">
                <span class="setting-label">Auto Reload</span>
                <button class="setting-toggle" id="settingAutoReload" type="button"></button>
              </div>
              <div class="setting-row">
                <span class="setting-label">Colorblind Mode</span>
                <button class="setting-toggle" id="settingColorblind" type="button"></button>
              </div>
            </div>
            <button class="settings-close" id="settingsClose" type="button">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

    const BASE_ARENA = {
      width: 26,
      depth: 18,
      bounds: { minX: -13, maxX: 13, minZ: -9, maxZ: 9 },
      ground: { width: 36, depth: 26 }
    };

    const CONFIG = {
      render: {
        referenceWidth: 1280,
        referenceHeight: 720,
        maxDpr: 2
      },
      arena: {
        width: BASE_ARENA.width,
        depth: BASE_ARENA.depth,
        bounds: { ...BASE_ARENA.bounds }
      },
      camera: {
        fov: 50,
        near: 0.1,
        far: 200,
        position: new THREE.Vector3(0, 22, 18), // More overhead, centered view
        lookAt: new THREE.Vector3(0, 0, 0)
      },
      lighting: {
        ambient: 0.35,
        hemi: 0.65,
        dir: 1.05
      },
      movement: {
        accel: 22,
        maxSpeed: 6.2,
        turnSpeed: THREE.MathUtils.degToRad(900),
        dashSpeed: 12.0,
        dashDuration: 0.12,
        dashCooldown: 1.1
      },
      weaponSwitch: {
        duration: 0.08
      },
      weapons: {
	        pistol: {
	          name: 'Pistol',
	          fireRate: 2.1,
	          fireRateAI: 2.0,
	          damage: 16,
	          magSize: 8,
	          reserveMax: 32,
	          reserveStart: 24,
	          dropChance: 0.4,
	          reload: 0.9,
	          reloadType: 'mag',
	          spreadPlayer: THREE.MathUtils.degToRad(0.7),
	          spreadAI: THREE.MathUtils.degToRad(1.8),
	          range: 34,
	          auto: false,
	          knockback: 0.45,
	          muzzleSize: 0.28,
	          tracer: 0xff4d00
	        },
        smg: {
          name: 'SMG',
          fireRate: 10,
          fireRateAI: 6.0,
          damage: 8,
          magSize: 30,
          reserveMax: 90,
          reserveStart: 0,
          dropChance: 0.35,
          reload: 1.2,
          reloadType: 'mag',
          spreadPlayer: THREE.MathUtils.degToRad(4.0),
          spreadAI: THREE.MathUtils.degToRad(7.0),
          range: 28,
          auto: true,
          knockback: 0.2,
          muzzleSize: 0.34,
          tracer: 0xffffff
        },
        shotgun: {
          name: 'Shotgun',
          fireRate: 1.2,
          fireRateAI: 1.0,
          damage: 12,
          pellets: 6,
          magSize: 4,
          reserveMax: 24,
          reserveStart: 0,
          dropChance: 0.25,
          reload: 0.5,
          reloadType: 'shell',
          spreadPlayer: THREE.MathUtils.degToRad(12),
          spreadAI: THREE.MathUtils.degToRad(14),
          range: 12,
          auto: false,
          knockback: 2.5,
          muzzleSize: 0.46,
          tracer: 0xffcc00
        }
      },
      nearMissDrama: {
        distance: 0.35,
        cooldown: 3.0,
        timeScale: 0.3,
        duration: 0.5,
        cameraZoom: 1.15
      },
      kick: {
        range: 1.5,
        cooldown: 0.9,
        coverSlideSpeed: 12,
        coverSlideDuration: 0.42,
        coverHitDamage: 20,
        coverHitStun: 0.3,
        barrelRollSpeed: 12,
        barrelRollTime: 2.0
      },
      cover: {
        flashTime: 0.08,
        types: {
          Crate: { hp: 30 },
          CardboardBoxes_1: { hp: 15 },
          CardboardBoxes_2: { hp: 15 },
          CardboardBoxes_3: { hp: 15 },
          CardboardBoxes_4: { hp: 15 },
          Pallet: { hp: 20 },
          Sofa: { hp: 40 }
        }
      },
	      barrel: {
	        hp: 30,
	        radius: 0.65,
	        explosionRadius: 3.6,
	        maxDamage: 55
	      },
	      grenade: {
	        radius: 0.22,
	        throwSpeed: 12.5,
	        throwUp: 8.4,
	        gravity: -18,
	        fuse: 1.05,
	        cooldown: 2.4,
	        ammoMax: 2,
	        ammoStart: 2,
	        explosionRadius: 5.2,
	        maxDamage: 160,
	        knockback: 26.0,
	        stun: 1.35,
	        wallBounce: 0.55,
	        groundBounce: 0.35,
	        drag: 0.06
	      },
	      difficulty: {
	        byMode: { duel: 'easy', deathmatch: 'normal' }, // 'easy' | 'normal' | 'hard'
	        presets: {
	          easy: { aiHp: 80, aiDamageMul: 0.75, aiFireRateMul: 0.82, aiSpreadMul: 1.8, aiThinkBase: 0.62, aiThinkJitter: 0.45 },
	          normal: { aiHp: 100, aiDamageMul: 1.0, aiFireRateMul: 1.0, aiSpreadMul: 1.0, aiThinkBase: 0.35, aiThinkJitter: 0.30 },
	          hard: { aiHp: 110, aiDamageMul: 1.05, aiFireRateMul: 1.12, aiSpreadMul: 0.9, aiThinkBase: 0.26, aiThinkJitter: 0.22 }
	        }
	      },
	      player: {
	        height: 1.75,
	        radius: 0.35,
	        hurtRadius: 0.42 // Larger hitbox makes shooting easier
	      },
      match: {
        totalTime: 105,
        roundsToWin: 3
      },
      pickups: {
        floatHeight: 0.5,
        bobAmount: 0.15,
        bobSpeed: 2.0,
        rotateSpeed: 1.5,
        collectRadius: 1.2,
        crateDropChance: 0.7,
        skyDropInterval: 15,
        skyDropVariance: 5
      },
      gameModes: {
        duel: { name: '1v1 Duel', playerCount: 2, arenaScale: 1.0, aiCount: 1 },
        deathmatch: { name: '4-Player FFA', playerCount: 4, arenaScale: 1.3, aiCount: 3, lives: 3 }
      },
      powerups: {
        types: {
          health: { name: 'Health Pack', color: 0x00ff00, effect: { hp: 50 }, duration: 0 },
          speed: { name: 'Speed Boost', color: 0x00bcd4, effect: { speedMul: 1.5 }, duration: 8 },
          damage: { name: 'Damage Up', color: 0xff4d00, effect: { damageMul: 1.5 }, duration: 8 },
          shield: { name: 'Shield', color: 0xffcc00, effect: { shield: 30 }, duration: 0 }
        },
        spawnInterval: 20,
        spawnVariance: 8,
        collectRadius: 1.0,
        floatHeight: 0.6,
        bobAmount: 0.2,
        bobSpeed: 2.5
      },
      audio: {
        masterVolume: 0.7,
        sfxVolume: 0.8,
        musicVolume: 0.5
      }
    };

    // ==================== AUDIO SYSTEM ====================
    const AudioManager = {
      ctx: null,
      masterGain: null,
      sfxGain: null,
      musicGain: null,
      initialized: false,

      init() {
        if (this.initialized) return;
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.ctx.createGain();
          this.sfxGain = this.ctx.createGain();
          this.musicGain = this.ctx.createGain();
          this.sfxGain.connect(this.masterGain);
          this.musicGain.connect(this.masterGain);
          this.masterGain.connect(this.ctx.destination);
          this.setVolumes();
          this.initialized = true;
        } catch (e) {
          console.warn('AudioContext not available:', e);
        }
      },

      setVolumes() {
        if (!this.masterGain) return;
        this.masterGain.gain.value = CONFIG.audio.masterVolume;
        this.sfxGain.gain.value = CONFIG.audio.sfxVolume;
        this.musicGain.gain.value = CONFIG.audio.musicVolume;
      },

      resume() {
        if (this.ctx && this.ctx.state === 'suspended') {
          this.ctx.resume();
        }
      },

      // Synth sound generators
      playPistol() {
        this.playSynth({ type: 'square', freq: 800, attack: 0.01, decay: 0.08, volume: 0.3 });
        this.playSynth({ type: 'noise', freq: 0, attack: 0.01, decay: 0.05, volume: 0.15 });
      },

      playSMG() {
        this.playSynth({ type: 'square', freq: 1200, attack: 0.005, decay: 0.04, volume: 0.2 });
        this.playSynth({ type: 'noise', freq: 0, attack: 0.005, decay: 0.03, volume: 0.1 });
      },

      playShotgun() {
        this.playSynth({ type: 'sawtooth', freq: 150, attack: 0.01, decay: 0.15, volume: 0.4 });
        this.playSynth({ type: 'noise', freq: 0, attack: 0.01, decay: 0.12, volume: 0.35 });
      },

      playSniper() {
        this.playSynth({ type: 'sine', freq: 2000, attack: 0.005, decay: 0.02, volume: 0.25 });
        this.playSynth({ type: 'square', freq: 400, attack: 0.01, decay: 0.2, volume: 0.35 });
        this.playSynth({ type: 'noise', freq: 0, attack: 0.01, decay: 0.15, volume: 0.2 });
      },

      playRocket() {
        this.playSynth({ type: 'sawtooth', freq: 80, attack: 0.02, decay: 0.3, volume: 0.3 });
        this.playSynth({ type: 'noise', freq: 0, attack: 0.02, decay: 0.25, volume: 0.2 });
      },

      playExplosion() {
        this.playSynth({ type: 'sawtooth', freq: 60, attack: 0.01, decay: 0.4, volume: 0.5 });
        this.playSynth({ type: 'noise', freq: 0, attack: 0.01, decay: 0.35, volume: 0.4 });
        this.playSynth({ type: 'sine', freq: 40, attack: 0.05, decay: 0.5, volume: 0.3 });
      },

      playHit() {
        this.playSynth({ type: 'sine', freq: 1800, attack: 0.005, decay: 0.06, volume: 0.25 });
      },

      playDeath() {
        this.playSynth({ type: 'sawtooth', freq: 400, attack: 0.01, decay: 0.3, freqEnd: 80, volume: 0.35 });
      },

      playReload() {
        this.playSynth({ type: 'square', freq: 600, attack: 0.01, decay: 0.05, volume: 0.15 });
        setTimeout(() => this.playSynth({ type: 'square', freq: 800, attack: 0.01, decay: 0.05, volume: 0.15 }), 100);
      },

      playDash() {
        this.playSynth({ type: 'sine', freq: 300, attack: 0.01, decay: 0.1, freqEnd: 600, volume: 0.2 });
      },

      playPickup() {
        this.playSynth({ type: 'sine', freq: 800, attack: 0.01, decay: 0.1, volume: 0.25 });
        setTimeout(() => this.playSynth({ type: 'sine', freq: 1200, attack: 0.01, decay: 0.1, volume: 0.25 }), 80);
      },

      playAchievement() {
        this.playSynth({ type: 'sine', freq: 600, attack: 0.01, decay: 0.15, volume: 0.3 });
        setTimeout(() => this.playSynth({ type: 'sine', freq: 900, attack: 0.01, decay: 0.15, volume: 0.3 }), 100);
        setTimeout(() => this.playSynth({ type: 'sine', freq: 1200, attack: 0.01, decay: 0.2, volume: 0.3 }), 200);
      },

      playMenuClick() {
        this.playSynth({ type: 'sine', freq: 1000, attack: 0.005, decay: 0.05, volume: 0.15 });
      },

      playRoundStart() {
        this.playSynth({ type: 'square', freq: 400, attack: 0.01, decay: 0.2, volume: 0.3 });
        setTimeout(() => this.playSynth({ type: 'square', freq: 600, attack: 0.01, decay: 0.3, volume: 0.35 }), 200);
      },

      playGrenade() {
        this.playSynth({ type: 'sine', freq: 500, attack: 0.01, decay: 0.1, freqEnd: 300, volume: 0.2 });
      },

      playNearMiss() {
        this.playSynth({ type: 'sine', freq: 1500, attack: 0.01, decay: 0.15, freqEnd: 800, volume: 0.2 });
      },

      playSynth(opts) {
        if (!this.ctx || !this.initialized) return;
        this.resume();
        const { type, freq, attack, decay, volume, freqEnd } = opts;
        const now = this.ctx.currentTime;

        if (type === 'noise') {
          const bufferSize = this.ctx.sampleRate * decay;
          const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          const noise = this.ctx.createBufferSource();
          noise.buffer = buffer;
          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(volume, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + decay);
          noise.connect(gain);
          gain.connect(this.sfxGain);
          noise.start(now);
          noise.stop(now + decay);
        } else {
          const osc = this.ctx.createOscillator();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, now);
          if (freqEnd) {
            osc.frequency.exponentialRampToValueAtTime(freqEnd, now + decay);
          }
          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(volume, now + attack);
          gain.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);
          osc.connect(gain);
          gain.connect(this.sfxGain);
          osc.start(now);
          osc.stop(now + attack + decay + 0.01);
        }
      }
    };

    // ==================== KEY BINDINGS SYSTEM ====================
    const DEFAULT_KEYBINDS = {
      moveUp: 'KeyW',
      moveDown: 'KeyS',
      moveLeft: 'KeyA',
      moveRight: 'KeyD',
      dash: 'Space',
      reload: 'KeyR',
      kick: 'KeyE',
      grenade: 'KeyG',
      weapon1: 'Digit1',
      weapon2: 'Digit2',
      weapon3: 'Digit3',
      weapon4: 'Digit4',
      weapon5: 'Digit5',
      pause: 'KeyP',
      settings: 'KeyO'
    };

    const KEYBIND_LABELS = {
      moveUp: 'Move Up',
      moveDown: 'Move Down',
      moveLeft: 'Move Left',
      moveRight: 'Move Right',
      dash: 'Dash',
      reload: 'Reload',
      kick: 'Kick / Interact',
      grenade: 'Throw Grenade',
      weapon1: 'Weapon 1 (Pistol)',
      weapon2: 'Weapon 2 (SMG)',
      weapon3: 'Weapon 3 (Shotgun)',
      weapon4: 'Weapon 4 (Sniper)',
      weapon5: 'Weapon 5 (Rocket)',
      pause: 'Pause Game',
      settings: 'Settings Menu'
    };

    const KeyBinds = {
      binds: { ...DEFAULT_KEYBINDS },
      
      load() {
        const stored = localStorage.getItem('tinyToonDuel_keybinds');
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            this.binds = { ...DEFAULT_KEYBINDS, ...parsed };
          } catch {}
        }
      },
      
      save() {
        localStorage.setItem('tinyToonDuel_keybinds', JSON.stringify(this.binds));
      },
      
      reset() {
        this.binds = { ...DEFAULT_KEYBINDS };
        this.save();
      },
      
      getAction(keyCode) {
        for (const [action, key] of Object.entries(this.binds)) {
          if (key === keyCode) return action;
        }
        return null;
      },
      
      getKey(action) {
        return this.binds[action] || null;
      },
      
      rebind(action, newKey) {
        // Remove any existing binding for this key
        for (const [existingAction, key] of Object.entries(this.binds)) {
          if (key === newKey && existingAction !== action) {
            this.binds[existingAction] = null;
          }
        }
        this.binds[action] = newKey;
        this.save();
      },
      
      keyCodeToDisplayName(code) {
        if (!code) return '---';
        const keyNames = {
          'Space': 'SPACE',
          'ShiftLeft': 'L-SHIFT',
          'ShiftRight': 'R-SHIFT',
          'ControlLeft': 'L-CTRL',
          'ControlRight': 'R-CTRL',
          'AltLeft': 'L-ALT',
          'AltRight': 'R-ALT',
          'ArrowUp': '↑',
          'ArrowDown': '↓',
          'ArrowLeft': '←',
          'ArrowRight': '→',
          'Escape': 'ESC',
          'Enter': 'ENTER',
          'Tab': 'TAB',
          'Backspace': 'BACK'
        };
        if (keyNames[code]) return keyNames[code];
        if (code.startsWith('Key')) return code.slice(3);
        if (code.startsWith('Digit')) return code.slice(5);
        if (code.startsWith('Numpad')) return 'NUM' + code.slice(6);
        return code;
      }
    };

    // ==================== ACHIEVEMENTS SYSTEM ====================
    const ACHIEVEMENTS = {
      first_blood: { name: 'First Blood', desc: 'Win your first match' },
      headhunter: { name: 'Headhunter', desc: 'Get 10 kills in a single match' },
      untouchable: { name: 'Untouchable', desc: 'Win a round without taking damage' },
      speedrunner: { name: 'Speedrunner', desc: 'Win a match in under 30 seconds' },
      demolition: { name: 'Demolition Expert', desc: 'Get 3 kills with a single explosion' },
      sharpshooter: { name: 'Sharpshooter', desc: 'Achieve 80% accuracy in a match' },
      domination: { name: 'Domination', desc: 'Win 3-0 in a duel' },
      survivor: { name: 'Survivor', desc: 'Win with less than 10 HP' },
      weapon_master: { name: 'Weapon Master', desc: 'Get kills with all weapons in one match' },
      close_call: { name: 'Close Call', desc: 'Survive 5 near misses in a match' }
    };

    // ==================== PERSISTENT STATS ====================
    const PlayerStats = {
      data: {
        totalKills: 0,
        totalDeaths: 0,
        matchesPlayed: 0,
        matchesWon: 0,
        totalDamageDealt: 0,
        bestAccuracy: 0,
        bestWinStreak: 0,
        currentWinStreak: 0,
        achievements: [],
        weaponKills: { pistol: 0, smg: 0, shotgun: 0, sniper: 0, rocket: 0 }
      },

      load() {
        const stored = localStorage.getItem('tinyToonDuel_playerStats');
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            this.data = { ...this.data, ...parsed };
          } catch {}
        }
      },

      save() {
        localStorage.setItem('tinyToonDuel_playerStats', JSON.stringify(this.data));
      },

      addKill(weaponId) {
        this.data.totalKills++;
        if (this.data.weaponKills[weaponId] !== undefined) {
          this.data.weaponKills[weaponId]++;
        }
        this.save();
      },

      addDeath() {
        this.data.totalDeaths++;
        this.save();
      },

      recordMatch(won, accuracy) {
        this.data.matchesPlayed++;
        if (won) {
          this.data.matchesWon++;
          this.data.currentWinStreak++;
          this.data.bestWinStreak = Math.max(this.data.bestWinStreak, this.data.currentWinStreak);
        } else {
          this.data.currentWinStreak = 0;
        }
        if (accuracy > this.data.bestAccuracy) {
          this.data.bestAccuracy = accuracy;
        }
        this.save();
      },

      unlockAchievement(id) {
        if (!this.data.achievements.includes(id) && ACHIEVEMENTS[id]) {
          this.data.achievements.push(id);
          this.save();
          return true;
        }
        return false;
      },

      hasAchievement(id) {
        return this.data.achievements.includes(id);
      }
    };

    // ==================== GAME SETTINGS ====================
    const GameSettings = {
      data: {
        masterVolume: 0.7,
        sfxVolume: 0.8,
        musicVolume: 0.5,
        autoReload: false,
        colorblindMode: false,
        showDamageNumbers: true,
        showKillFeed: true
      },

      load() {
        const stored = localStorage.getItem('tinyToonDuel_settings');
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            this.data = { ...this.data, ...parsed };
          } catch {}
        }
        this.apply();
      },

      save() {
        localStorage.setItem('tinyToonDuel_settings', JSON.stringify(this.data));
        this.apply();
      },

      apply() {
        CONFIG.audio.masterVolume = this.data.masterVolume;
        CONFIG.audio.sfxVolume = this.data.sfxVolume;
        CONFIG.audio.musicVolume = this.data.musicVolume;
        if (AudioManager.initialized) {
          AudioManager.setVolumes();
        }
      }
    };

    // ==================== SVG ICONS ====================
    const ICONS = {
      health: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>',
      speed: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>',
      damage: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>',
      shield: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg>',
      star: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>',
      trophy: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.98 2.63 3.61 2.96V19H7v2h10v-2h-4v-3.1c1.63-.33 2.98-1.46 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z"/></svg>',
      target: '<svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="12" r="2"/></svg>',
      skull: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12v8h4v-2h2v2h4v-2h2v2h4v-2h2v-8c0-5.52-4.48-10-10-10zm-3 11c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6 0c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>',
      rocket: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.5s-5 3-5 10c0 3.5 1.5 6 1.5 6h7s1.5-2.5 1.5-6c0-7-5-10-5-10zm0 11.5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/><path d="M5.5 16L3 22l4-2-1.5-4zm13 0L22 22l-4-2 1.5-4z"/></svg>',
      crosshair: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="8"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>',
      settings: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>'
    };

    // Add new weapons to CONFIG
    CONFIG.weapons.sniper = {
      name: 'Sniper',
      fireRate: 0.8,
      fireRateAI: 0.6,
      damage: 85,
      magSize: 5,
      reserveMax: 15,
      reserveStart: 0,
      dropChance: 0.15,
      reload: 1.8,
      reloadType: 'mag',
      spreadPlayer: THREE.MathUtils.degToRad(0.2),
      spreadAI: THREE.MathUtils.degToRad(0.8),
      range: 60,
      auto: false,
      knockback: 2.0,
      muzzleSize: 0.38,
      tracer: 0x00ff88
    };

    CONFIG.weapons.rocket = {
      name: 'Rocket',
      fireRate: 0.6,
      fireRateAI: 0.5,
      damage: 0,
      magSize: 2,
      reserveMax: 6,
      reserveStart: 0,
      dropChance: 0.1,
      reload: 2.2,
      reloadType: 'mag',
      spreadPlayer: THREE.MathUtils.degToRad(0.5),
      spreadAI: THREE.MathUtils.degToRad(1.5),
      range: 40,
      auto: false,
      projectile: true,
      explosionRadius: 4.0,
      explosionDamage: 90,
      projectileSpeed: 18,
      knockback: 0,
      muzzleSize: 0.5,
      tracer: 0xff6600
    };

    const COLORS = {
      dust: 0xC9A36A,
      dustDark: 0x8B6A3E,
      steel: 0x333333,      // Dark Metal
      p1: 0x00ff00,         // Phosphor Green
      p2: 0xff0000,         // LED Red
      p3: 0x00bcd4,         // Terminal Cyan
      p4: 0xffcc00,         // Industrial Yellow
      warning: 0xffcc00,
      tracer: 0xff4d00,     // Primary Orange
      near: 0x00bcd4
    };

    const MODEL_YAW_OFFSET = 0; // adjust if character forward differs from -Z
    const SPAWN_POINTS = [
      new THREE.Vector3(-9, 0, 0),
      new THREE.Vector3(9, 0, 0),
      new THREE.Vector3(0, 0, -7),
      new THREE.Vector3(0, 0, 7)
    ];

    const canvas = document.getElementById('scene');
    const canvasWrap = document.getElementById('canvasWrap');
    const hud = document.getElementById('hud');
    const timerEl = document.getElementById('timer');
    const playerPanelsEl = document.getElementById('playerPanels');
    const roundPipsEl = document.getElementById('roundPips');
    const bannerEl = document.getElementById('banner');
    const menuOverlay = document.getElementById('menuOverlay');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const matchOverlay = document.getElementById('matchOverlay');
    const leaderboardOverlay = document.getElementById('leaderboardOverlay');
	    const leaderboardList = document.getElementById('leaderboardList');
	    const matchTitle = document.getElementById('matchTitle');
	    const matchStats = document.getElementById('matchStats');
	    const bestTimeEl = document.getElementById('bestTime');
	    const bestTimeEnd = document.getElementById('bestTimeEnd');
	    const visualToggleBtn = document.getElementById('visualToggle');
	    const visualToggleLabel = document.getElementById('visualToggleLabel');
	    const dashEl = document.getElementById('dash');
	    const dashCooldownEl = dashEl.querySelector('.cooldown');
		    const modeSubtitleEl = document.getElementById('modeSubtitle');
		    const modeRulesEl = document.getElementById('modeRules');
		    const modeButtons = Array.from(document.querySelectorAll('.modeBtn'));
	    const difficultyLabelEl = document.getElementById('difficultyLabel');
	    const difficultyButtons = Array.from(document.querySelectorAll('.difficultyBtn'));
	    const nearMissFlash = document.getElementById('nearMissFlash');
	    const hitFlash = document.getElementById('hitFlash');
	    const lowHpVignette = document.getElementById('lowHpVignette');
    const dramaticOverlay = document.getElementById('dramaticOverlay');
    const popupsEl = document.getElementById('popups');
    const killCamTextEl = document.getElementById('killCamText');
    const suddenDeathEl = document.getElementById('suddenDeath');

    const input = {
      keys: {},
      mouse: { x: 0, y: 0, down: false, justPressed: false }
    };

    const hudPanels = new Map();

    const raycaster = new THREE.Raycaster();
    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

	    const state = {
	      mode: 'loading',
	      gameMode: 'duel',
	      activeGameMode: null,
      showLeaderboard: false,
      timeLeft: CONFIG.match.totalTime,
      round: 1,
      wins: { p1: 0, p2: 0 },
      roundResults: [],
      lives: {},
      bestWinTime: null,
      matchStartTime: null,
      suddenDeath: false,
      roundEnding: false,
      matchEnded: false,
      lastKill: null,
	      killCam: null
	    };

	    const settings = {
	      usePlaceholders: false
	    };

	    const storedVisualMode = localStorage.getItem('tinyToonDuel_visualMode');
	    if (storedVisualMode === 'placeholder') {
	      settings.usePlaceholders = true;
	    }

	    const fx = {
	      shakeTime: 0,
	      shakeIntensity: 0,
      fovPulse: 0,
      fovVelocity: 0,
      hitFlashTimer: 0,
      nearMissTimer: 0,
      dramaticTimer: 0,
      dramaticTeam: null,
      timeScale: 1,
      timeScaleTimer: 0,
      hitstopTimer: 0
    };

    const assets = {
      cache: new Map(),
      manifest: null
    };

		    const world = {
		      scene: new THREE.Scene(),
		      camera: null,
		      renderer: null,
	      clock: new THREE.Clock(),
	      mixers: [],
	      entities: [],
	      cover: [],
	      barrels: [],
	      spilledBarrels: [], // Track spilled barrel meshes for cleanup
	      grenades: [],
	      pickups: [],
	      fallingCrates: [],
	      skyDropTimer: 0,
	      arenaObjects: [],
	      nodes: [],
      fxLines: [],
      fxSprites: [],
      fxParticles: [], // Hit effect particles
      popups: [],
      cameraState: null,
	      reticle: null,
	      gunMuzzleFlashes: [],
	      arenaLayout: null,
	      arenaDecor: []
	    };

	    const stored = localStorage.getItem('tinyToonDuel_bestWinSeconds');
	    if (stored) {
	      const parsed = Number(stored);
	      if (!Number.isNaN(parsed)) state.bestWinTime = parsed;
	    }

	    const storedDifficulty = localStorage.getItem('tinyToonDuel_aiDifficultyByMode');
	    if (storedDifficulty) {
	      try {
	        const parsed = JSON.parse(storedDifficulty);
	        if (parsed && typeof parsed === 'object') {
	          CONFIG.difficulty.byMode = { ...CONFIG.difficulty.byMode, ...parsed };
	        }
	      } catch {}
	    }

	    init();

	    async function init() {
      // Load persistent data
      GameSettings.load();
      PlayerStats.load();
      KeyBinds.load();
      
      setupRenderer();
      setupScene();
      setupCamera();
      setupLights();
      bindInput();
      await loadAssets();
      setupVisualToggle();
      setupMenuModes();
      setupSettingsPanel();
      setupNavigationButtons();
      setupControlsPanel();
      applyColorblindMode();
      applyGameMode(state.gameMode);
      createReticle();
      setMode('menu');
      animate();
      
      // Initialize audio on first user interaction
      const initAudio = () => {
        AudioManager.init();
        document.removeEventListener('click', initAudio);
        document.removeEventListener('keydown', initAudio);
      };
      document.addEventListener('click', initAudio);
      document.addEventListener('keydown', initAudio);
    }

	    function setupVisualToggle() {
	      if (!visualToggleBtn || !visualToggleLabel) return;
	      updateVisualToggleUI();
	      visualToggleBtn.addEventListener('click', () => {
	        setVisualMode(!settings.usePlaceholders);
	      });
	    }

	    function updateVisualToggleUI() {
	      if (!visualToggleLabel) return;
	      visualToggleLabel.textContent = settings.usePlaceholders ? 'PLACEHOLDER' : 'GLTF';
	    }

	    function setVisualMode(usePlaceholders) {
	      settings.usePlaceholders = Boolean(usePlaceholders);
	      localStorage.setItem('tinyToonDuel_visualMode', settings.usePlaceholders ? 'placeholder' : 'gltf');
	      updateVisualToggleUI();
	      if (assets.manifest) {
	        swapAllVisuals();
	        showBanner(settings.usePlaceholders ? 'VISUALS: PLACEHOLDERS' : 'VISUALS: GLTF');
	      }
	    }

    function setupRenderer() {
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, CONFIG.render.maxDpr));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      world.renderer = renderer;
      resize();
      window.addEventListener('resize', resize);
    }

    function setupScene() {
      world.scene.background = new THREE.Color(0xCFE6FF);
      world.scene.fog = new THREE.Fog(0xEFD9B1, 24, 70);
    }

    function setupCamera() {
      const camera = new THREE.PerspectiveCamera(
        CONFIG.camera.fov,
        CONFIG.render.referenceWidth / CONFIG.render.referenceHeight,
        CONFIG.camera.near,
        CONFIG.camera.far
      );
      camera.position.copy(CONFIG.camera.position);
      camera.lookAt(CONFIG.camera.lookAt);
      world.camera = camera;
    }

    function setupLights() {
      const ambient = new THREE.AmbientLight(0xffffff, CONFIG.lighting.ambient);
      const hemi = new THREE.HemisphereLight(0xffffff, 0x96754b, CONFIG.lighting.hemi);
      const dir = new THREE.DirectionalLight(0xfff2d6, CONFIG.lighting.dir);
      dir.position.set(12, 24, 8);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024, 1024);
      dir.shadow.camera.left = -20;
      dir.shadow.camera.right = 20;
      dir.shadow.camera.top = 20;
      dir.shadow.camera.bottom = -20;
      dir.shadow.camera.near = 1;
      dir.shadow.camera.far = 60;
      world.scene.add(ambient, hemi, dir);
    }

    // ==================== SETTINGS PANEL ====================
    function setupSettingsPanel() {
      const overlay = document.getElementById('settingsOverlay');
      const masterVol = document.getElementById('settingMasterVol');
      const sfxVol = document.getElementById('settingSfxVol');
      const damageNumbers = document.getElementById('settingDamageNumbers');
      const autoReload = document.getElementById('settingAutoReload');
      const colorblind = document.getElementById('settingColorblind');
      const closeBtn = document.getElementById('settingsClose');
      
      if (!overlay) return;
      
      // Initialize values from GameSettings
      if (masterVol) {
        masterVol.value = GameSettings.data.masterVolume * 100;
        masterVol.addEventListener('input', () => {
          GameSettings.data.masterVolume = masterVol.value / 100;
          GameSettings.save();
        });
      }
      
      if (sfxVol) {
        sfxVol.value = GameSettings.data.sfxVolume * 100;
        sfxVol.addEventListener('input', () => {
          GameSettings.data.sfxVolume = sfxVol.value / 100;
          GameSettings.save();
        });
      }
      
      if (damageNumbers) {
        damageNumbers.classList.toggle('active', GameSettings.data.showDamageNumbers);
        damageNumbers.addEventListener('click', () => {
          GameSettings.data.showDamageNumbers = !GameSettings.data.showDamageNumbers;
          damageNumbers.classList.toggle('active', GameSettings.data.showDamageNumbers);
          GameSettings.save();
          AudioManager.playMenuClick();
        });
      }
      
      if (autoReload) {
        autoReload.classList.toggle('active', GameSettings.data.autoReload);
        autoReload.addEventListener('click', () => {
          GameSettings.data.autoReload = !GameSettings.data.autoReload;
          autoReload.classList.toggle('active', GameSettings.data.autoReload);
          GameSettings.save();
          AudioManager.playMenuClick();
        });
      }
      
      if (colorblind) {
        colorblind.classList.toggle('active', GameSettings.data.colorblindMode);
        colorblind.addEventListener('click', () => {
          GameSettings.data.colorblindMode = !GameSettings.data.colorblindMode;
          colorblind.classList.toggle('active', GameSettings.data.colorblindMode);
          GameSettings.save();
          AudioManager.playMenuClick();
          applyColorblindMode();
        });
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          overlay.classList.remove('visible');
          AudioManager.playMenuClick();
        });
      }
    }
    
    function toggleSettings() {
      const overlay = document.getElementById('settingsOverlay');
      if (!overlay) return;
      overlay.classList.toggle('visible');
      AudioManager.playMenuClick();
    }
    
    function applyColorblindMode() {
      // Apply colorblind-friendly color scheme
      if (GameSettings.data.colorblindMode) {
        document.documentElement.style.setProperty('--p1', '#0077bb'); // Blue instead of green
        document.documentElement.style.setProperty('--p2', '#ee7733'); // Orange instead of red
      } else {
        document.documentElement.style.setProperty('--p1', '#00ff00');
        document.documentElement.style.setProperty('--p2', '#ff0000');
      }
    }

    // ==================== NAVIGATION BUTTONS ====================
    function setupNavigationButtons() {
      // Pause menu buttons
      const btnResume = document.getElementById('btnResume');
      const btnPauseSettings = document.getElementById('btnPauseSettings');
      const btnControls = document.getElementById('btnControls');
      const btnMainMenu = document.getElementById('btnMainMenu');
      const btnHub = document.getElementById('btnHub');
      
      if (btnResume) {
        btnResume.addEventListener('click', () => {
          AudioManager.playMenuClick();
          togglePause();
        });
      }
      
      if (btnPauseSettings) {
        btnPauseSettings.addEventListener('click', () => {
          AudioManager.playMenuClick();
          toggleSettings();
        });
      }
      
      if (btnControls) {
        btnControls.addEventListener('click', () => {
          AudioManager.playMenuClick();
          toggleControlsPanel();
        });
      }
      
      if (btnMainMenu) {
        btnMainMenu.addEventListener('click', () => {
          AudioManager.playMenuClick();
          returnToMainMenu();
        });
      }
      
      if (btnHub) {
        btnHub.addEventListener('click', () => {
          AudioManager.playMenuClick();
          returnToHub();
        });
      }
      
      // Match over buttons
      const btnRematch = document.getElementById('btnRematch');
      const btnMatchMainMenu = document.getElementById('btnMatchMainMenu');
      const btnMatchHub = document.getElementById('btnMatchHub');
      
      if (btnRematch) {
        btnRematch.addEventListener('click', () => {
          AudioManager.playMenuClick();
          startMatch();
        });
      }
      
      if (btnMatchMainMenu) {
        btnMatchMainMenu.addEventListener('click', () => {
          AudioManager.playMenuClick();
          returnToMainMenu();
        });
      }
      
      if (btnMatchHub) {
        btnMatchHub.addEventListener('click', () => {
          AudioManager.playMenuClick();
          returnToHub();
        });
      }
    }
    
    function returnToMainMenu() {
      state.mode = 'menu';
      state.matchEnded = false;
      state.roundEnding = false;
      setMode('menu');
    }
    
    function returnToHub() {
      window.location.href = '../../index.html';
    }
    
    function toggleControlsPanel() {
      const overlay = document.getElementById('controlsOverlay');
      if (!overlay) return;
      overlay.classList.toggle('visible');
      if (overlay.classList.contains('visible')) {
        renderControlsList();
      }
    }

    // ==================== CONTROLS PANEL ====================
    let rebindingAction = null;
    
    function setupControlsPanel() {
      const closeBtn = document.getElementById('controlsClose');
      const resetBtn = document.getElementById('btnResetControls');
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          AudioManager.playMenuClick();
          document.getElementById('controlsOverlay').classList.remove('visible');
          rebindingAction = null;
        });
      }
      
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          AudioManager.playMenuClick();
          KeyBinds.reset();
          renderControlsList();
        });
      }
      
      // Listen for key presses when rebinding
      document.addEventListener('keydown', (e) => {
        if (!rebindingAction) return;
        e.preventDefault();
        e.stopPropagation();
        
        // Don't allow Escape to be bound
        if (e.code === 'Escape') {
          rebindingAction = null;
          renderControlsList();
          return;
        }
        
        KeyBinds.rebind(rebindingAction, e.code);
        AudioManager.playMenuClick();
        rebindingAction = null;
        renderControlsList();
      }, true);
    }
    
    function renderControlsList() {
      const list = document.getElementById('controlsList');
      if (!list) return;
      
      list.innerHTML = '';
      
      for (const [action, label] of Object.entries(KEYBIND_LABELS)) {
        const row = document.createElement('div');
        row.className = 'control-row' + (rebindingAction === action ? ' rebinding' : '');
        
        const actionEl = document.createElement('span');
        actionEl.className = 'control-action';
        actionEl.textContent = label;
        
        const keyEl = document.createElement('button');
        keyEl.className = 'control-key' + (rebindingAction === action ? ' listening' : '');
        keyEl.textContent = rebindingAction === action 
          ? 'Press key...' 
          : KeyBinds.keyCodeToDisplayName(KeyBinds.getKey(action));
        keyEl.addEventListener('click', () => {
          AudioManager.playMenuClick();
          rebindingAction = action;
          renderControlsList();
        });
        
        row.appendChild(actionEl);
        row.appendChild(keyEl);
        list.appendChild(row);
      }
    }

    function resize() {
      const wrap = document.getElementById('canvasWrap');
      const width = wrap.clientWidth;
      const height = wrap.clientHeight;
      world.renderer.setSize(width, height, false);
      if (world.camera) {
        world.camera.aspect = width / height;
        world.camera.updateProjectionMatrix();
      }
    }

	    function bindInput() {
	      window.addEventListener('keydown', (event) => {
	        // Skip if rebinding controls
	        if (rebindingAction) return;
	        
	        input.keys[event.code] = true;
	        
	        // Get action from keybind
	        const action = KeyBinds.getAction(event.code);
	        
	        if (event.code === 'Tab') {
	          event.preventDefault();
	          state.showLeaderboard = true;
	        }
	        if (event.code === 'KeyV') {
	          setVisualMode(!settings.usePlaceholders);
	        }
	        if (event.code === 'Escape' || action === 'pause') {
	          togglePause();
	        }
	        if (action === 'settings') {
	          toggleSettings();
	        }
	        if (event.code === 'Enter') {
	          if (state.mode === 'menu') startMatch();
          if (state.mode === 'matchOver') startMatch();
        }
        if (action === 'dash') {
          if (state.mode === 'playing') {
            const player = getPlayer();
            tryDash(player);
          }
        }
        if (action === 'reload') {
          const player = getPlayer();
          if (state.mode === 'playing') {
            startReload(player);
          }
        }
	        if (state.mode === 'playing') {
	          const player = getPlayer();
	          if (action === 'weapon1') requestWeaponSwitch(player, 'pistol');
	          if (action === 'weapon2') requestWeaponSwitch(player, 'smg');
	          if (action === 'weapon3') requestWeaponSwitch(player, 'shotgun');
	          if (action === 'weapon4') requestWeaponSwitch(player, 'sniper');
	          if (action === 'weapon5') requestWeaponSwitch(player, 'rocket');
	          if (action === 'kick') tryKick(player);
	          if (action === 'grenade' && !event.repeat) tryThrowGrenade(player);
	        }
	      });

      window.addEventListener('keyup', (event) => {
        input.keys[event.code] = false;
        if (event.code === 'Tab') {
          state.showLeaderboard = false;
        }
      });

      window.addEventListener('pointerdown', (event) => {
        input.mouse.down = true;
        input.mouse.justPressed = true;
        updatePointer(event);
      });

      window.addEventListener('pointerup', () => {
        input.mouse.down = false;
      });

      window.addEventListener('pointermove', updatePointer);
    }

    function updatePointer(event) {
      const rect = canvas.getBoundingClientRect();
      input.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      input.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    async function loadAssets() {
      const response = await fetch('./assets.json');
      assets.manifest = await response.json();

      const manifest = assets.manifest.assets.toonshooter;
	      const requests = [
	        // Characters
	        manifest.characters.Character_Soldier,
	        manifest.characters.Character_Enemy,
	        // Guns
	        manifest.guns.Pistol,
	        manifest.guns.SMG,
	        manifest.guns.Shotgun,
	        manifest.guns.Grenade,
	        // Main cover
	        manifest.environment.Tank,
	        manifest.environment.Debris_BrokenCar,
	        manifest.environment.Container_Small,
        manifest.environment.Barrier_Large,
        manifest.environment.Crate,
        manifest.environment.SackTrench,
        manifest.environment.Sofa,
        manifest.environment.Structure_1,
        manifest.environment.Pallet,
        // Decorative
        manifest.environment.CardboardBoxes_1,
        manifest.environment.CardboardBoxes_2,
        manifest.environment.CardboardBoxes_3,
        manifest.environment.CardboardBoxes_4,
        manifest.environment.Debris_Tires,
        manifest.environment.TrafficCone,
        manifest.environment.Debris_Pile,
        manifest.environment.Debris_Papers_1,
        manifest.environment.Debris_Papers_2,
        manifest.environment.Debris_Papers_3,
        manifest.environment.GasCan,
        manifest.environment.WoodPlanks,
        manifest.environment.Pallet_Broken,
        manifest.environment.Pipes,
        manifest.environment.TrashContainer,
        manifest.environment.TrashContainer_Open,
        manifest.environment.StreetLight,
        manifest.environment.Sign,
        // Boundary
        manifest.environment.Fence_Long,
        // Barrels
        manifest.environment.ExplodingBarrel,
        manifest.environment.ExplodingBarrel_Spilled
      ].filter(Boolean); // Filter out any undefined paths

      await Promise.all(requests.map(path => loadGltf(path)));
    }

	    async function loadGltf(path) {
	      if (assets.cache.has(path)) return assets.cache.get(path);

	      const url =
	        (typeof path === 'string' && !(path.startsWith('http') || path.startsWith('../') || path.startsWith('/')))
	          ? `${path}`
	          : path;

	      const loader = new GLTFLoader();
	      const entry = await new Promise((resolve) => {
	        loader.load(
	          url,
	          (gltf) => {
	            const root = gltf.scene;
	            let hasSkinned = false;
	            root.traverse((child) => {
	              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
              if (child.isSkinnedMesh) hasSkinned = true;
            });
            resolve({ scene: root, animations: gltf.animations || [], hasSkinned });
          },
          undefined,
          () => {
            resolve({ scene: null, animations: [], hasSkinned: false, failed: true });
          }
        );
      });

      assets.cache.set(path, entry);
      return entry;
    }

	    function cloneAsset(path, { ignorePlaceholders = false } = {}) {
	      if (!ignorePlaceholders && settings.usePlaceholders) return null;
	      const entry = assets.cache.get(path);
	      if (!entry || entry.failed || !entry.scene) return null;
	      if (entry.hasSkinned || entry.animations.length) {
	        return { root: SkeletonUtils.clone(entry.scene), animations: entry.animations };
	      }
	      return { root: entry.scene.clone(true), animations: entry.animations };
	    }

	    function removeFromArray(arr, item) {
	      const idx = arr.indexOf(item);
	      if (idx >= 0) arr.splice(idx, 1);
	    }

	    function removeMixerEntry(entry) {
	      if (!entry) return;
	      entry.mixer?.stopAllAction?.();
	      removeFromArray(world.mixers, entry);
	    }

	    function markPlaceholder(root) {
	      if (!root) return root;
	      root.userData = root.userData || {};
	      root.userData.placeholder = true;
	      root.traverse?.((child) => {
	        child.userData = child.userData || {};
	        child.userData.placeholder = true;
	      });
	      return root;
	    }

	    function swapAllVisuals() {
	      const variant = settings.usePlaceholders ? 'placeholder' : 'gltf';
	      world.entities.forEach((entity) => swapEntityVisual(entity, variant));
	      world.cover.forEach((cover) => swapCoverVisual(cover, variant));
	      world.barrels.forEach((barrel) => swapBarrelVisual(barrel, variant));
	      world.grenades.forEach((grenade) => swapGrenadeVisual(grenade, variant));
	      world.pickups.forEach((pickup) => swapPickupVisual(pickup, variant));
	      world.fallingCrates.forEach((crate) => swapFallingCrateVisual(crate, variant));
	      world.arenaDecor.forEach((item) => swapArenaDecorVisual(item, variant));

	      if (settings.usePlaceholders && world.spilledBarrels.length) {
	        world.spilledBarrels.forEach((mesh) => world.scene.remove(mesh));
	      }
	    }

	    function ensureEntityVisual(entity, variant) {
	      if (!entity) return null;
	      entity.visuals = entity.visuals || { gltf: null, placeholder: null };
	      entity.visualAnimations = entity.visualAnimations || { gltf: [], placeholder: [] };
	      if (entity.visuals[variant]) return entity.visuals[variant];

	      if (variant === 'placeholder') {
	        const root = markPlaceholder(
	          new THREE.Mesh(
	            new THREE.CapsuleGeometry(0.35, 1.2, 6, 12),
	            new THREE.MeshStandardMaterial({ color: entity.color || 0xffffff })
	          )
	        );
	        root.castShadow = true;
	        root.receiveShadow = true;
	        entity.visuals.placeholder = root;
	        return root;
	      }

	      const clone = cloneAsset(entity.assetPath, { ignorePlaceholders: true });
	      if (!clone) return null;
	      const root = normalizeToHeight(clone.root, CONFIG.player.height);
	      root.traverse?.((child) => {
	        if (child.isMesh) {
	          child.castShadow = true;
	          child.receiveShadow = true;
	        }
	      });
	      entity.visuals.gltf = root;
	      entity.visualAnimations.gltf = clone.animations || [];
	      return root;
	    }

	    function swapEntityVisual(entity, variant) {
	      if (!entity || !entity.group) return;
	      entity.activeVisual = entity.activeVisual || (entity.visuals?.gltf ? 'gltf' : 'placeholder');
	      if (entity.activeVisual === variant) return;
	      const nextRoot = ensureEntityVisual(entity, variant);
	      if (!nextRoot) return;

	      if (entity.root && entity.root.parent === entity.group) {
	        entity.group.remove(entity.root);
	      }
	      entity.group.add(nextRoot);
	      entity.root = nextRoot;
	      entity.activeVisual = variant;

	      if (entity.mixers) removeMixerEntry(entity.mixers);
	      entity.mixers = null;
	      entity.originalMaterials = null;
	      entity.flashTimer = 0;

	      entity.guns = findBuiltInWeapons(entity.root);
	      if (variant === 'gltf') {
	        entity.mixers = setupAnimations(entity.root, entity.visualAnimations?.gltf || []);
	      }
	      syncWeaponVisibility(entity);
	    }

	    function ensureCoverVisual(cover, variant) {
	      if (!cover) return null;
	      cover.visuals = cover.visuals || { gltf: null, placeholder: null };
	      if (cover.visuals[variant]) return cover.visuals[variant];

	      if (variant === 'placeholder') {
	        const fb = world.arenaLayout?.fallbackSizes?.[cover.key];
	        const sizeX = fb?.[0] || Math.max(1, cover.maxX - cover.minX);
	        const sizeY = fb?.[1] || 1.2;
	        const sizeZ = fb?.[2] || Math.max(1, cover.maxZ - cover.minZ);
	        const root = markPlaceholder(
	          new THREE.Mesh(
	            new THREE.BoxGeometry(sizeX, sizeY, sizeZ),
	            new THREE.MeshStandardMaterial({ color: COLORS.steel, roughness: 0.7, metalness: 0.1 })
	          )
	        );
	        root.castShadow = true;
	        root.receiveShadow = true;
	        cover.visuals.placeholder = root;
	        return root;
	      }

	      const clone = cloneAsset(cover.assetPath, { ignorePlaceholders: true });
	      if (!clone) return null;
	      const root = normalizeToHeight(clone.root, null);
	      root.traverse?.((child) => {
	        if (child.isMesh) {
	          child.castShadow = true;
	          child.receiveShadow = true;
	        }
	      });
	      cover.visuals.gltf = root;
	      return root;
	    }

		    function swapCoverVisual(cover, variant) {
		      if (!cover || !cover.mesh) return;
		      cover.activeVisual = cover.activeVisual || (cover.visuals?.gltf ? 'gltf' : 'placeholder');
		      if (cover.activeVisual === variant) return;
		      const nextMesh = ensureCoverVisual(cover, variant);
		      if (!nextMesh) return;

	      const oldMesh = cover.mesh;
	      const x = oldMesh.position.x;
	      const z = oldMesh.position.z;
	      const rotY = oldMesh.rotation.y;
	      const visible = oldMesh.visible;

	      world.scene.remove(oldMesh);
	      removeFromArray(world.arenaObjects, oldMesh);

	      if (variant === 'gltf') {
	        nextMesh.position.set(x, nextMesh.position.y, z);
	      } else {
	        nextMesh.position.set(x, nextMesh.geometry?.parameters?.height ? nextMesh.geometry.parameters.height / 2 : 0.6, z);
	      }
	      nextMesh.rotation.y = rotY;
	      nextMesh.visible = visible;

	      world.scene.add(nextMesh);
	      world.arenaObjects.push(nextMesh);

		      cover.mesh = nextMesh;
		      cover.activeVisual = variant;

		      cover.originalMaterials = null;
		      cover.flashTimer = 0;
		      cacheCoverColliderOffsets(cover);
		    }

	    function ensureBarrelVisual(barrel, variant) {
	      if (!barrel) return null;
	      barrel.visuals = barrel.visuals || { gltf: null, placeholder: null };
	      if (barrel.visuals[variant]) return barrel.visuals[variant];

	      if (variant === 'placeholder') {
	        const root = markPlaceholder(
	          new THREE.Mesh(
	            new THREE.CylinderGeometry(0.45, 0.45, 1.2, 12),
	            new THREE.MeshStandardMaterial({ color: COLORS.warning, roughness: 0.4, metalness: 0.2 })
	          )
	        );
	        root.castShadow = true;
	        root.receiveShadow = true;
	        barrel.visuals.placeholder = root;
	        return root;
	      }

	      const clone = cloneAsset(barrel.assetPath, { ignorePlaceholders: true });
	      if (!clone) return null;
	      const root = normalizeToHeight(clone.root, null);
	      root.traverse?.((child) => {
	        if (child.isMesh) {
	          child.castShadow = true;
	          child.receiveShadow = true;
	        }
	      });
	      barrel.visuals.gltf = root;
	      return root;
	    }

	    function swapBarrelVisual(barrel, variant) {
	      if (!barrel || !barrel.mesh) return;
	      barrel.activeVisual = barrel.activeVisual || (barrel.visuals?.gltf ? 'gltf' : 'placeholder');
	      if (barrel.activeVisual === variant) return;
	      const nextMesh = ensureBarrelVisual(barrel, variant);
	      if (!nextMesh) return;

	      const oldMesh = barrel.mesh;
	      const pos = oldMesh.position.clone();
	      const rot = oldMesh.rotation.clone();
	      const visible = oldMesh.visible;

	      world.scene.remove(oldMesh);

	      if (variant === 'gltf') {
	        nextMesh.position.set(pos.x, nextMesh.position.y, pos.z);
	      } else {
	        nextMesh.position.set(pos.x, 0.6, pos.z);
	      }
	      nextMesh.rotation.copy(rot);
	      nextMesh.visible = visible;

	      world.scene.add(nextMesh);
	      barrel.mesh = nextMesh;
	      barrel.position = nextMesh.position;
	      barrel.activeVisual = variant;
	    }

	    function swapPickupVisual(pickup, variant) {
	      if (!pickup || !pickup.mesh) return;
	      pickup.activeVisual = pickup.activeVisual || (pickup.visuals?.gltf ? 'gltf' : 'placeholder');
	      if (pickup.activeVisual === variant) return;
	      const nextMesh = ensurePickupVisual(pickup, variant);
	      if (!nextMesh) return;

	      const oldMesh = pickup.mesh;
	      const pos = oldMesh.position.clone();
	      const rotY = oldMesh.rotation.y;

	      world.scene.remove(oldMesh);
	      nextMesh.position.copy(pos);
	      nextMesh.rotation.y = rotY;
	      world.scene.add(nextMesh);

	      pickup.mesh = nextMesh;
	      pickup.activeVisual = variant;
	    }

		    function ensurePickupVisual(pickup, variant) {
		      pickup.visuals = pickup.visuals || { gltf: null, placeholder: null };
		      if (pickup.visuals[variant]) return pickup.visuals[variant];
		      const { mesh } = createPickupMesh(pickup.weaponId, { ignorePlaceholders: variant === 'gltf' });
		      pickup.visuals[variant] = mesh;
		      return mesh;
		    }

		    function swapGrenadeVisual(grenade, variant) {
		      if (!grenade || !grenade.mesh) return;
		      grenade.activeVisual = grenade.activeVisual || (grenade.visuals?.gltf ? 'gltf' : 'placeholder');
		      if (grenade.activeVisual === variant) return;
		      const nextMesh = ensureGrenadeVisual(grenade, variant);
		      if (!nextMesh) return;

		      const oldMesh = grenade.mesh;
		      const pos = oldMesh.position.clone();
		      const rot = oldMesh.rotation.clone();
		      const visible = oldMesh.visible;

		      world.scene.remove(oldMesh);
		      nextMesh.position.copy(pos);
		      nextMesh.rotation.copy(rot);
		      nextMesh.visible = visible;
		      world.scene.add(nextMesh);

		      grenade.mesh = nextMesh;
		      grenade.position = nextMesh.position;
		      grenade.activeVisual = variant;
		    }

		    function ensureGrenadeVisual(grenade, variant) {
		      grenade.visuals = grenade.visuals || { gltf: null, placeholder: null };
		      if (grenade.visuals[variant]) return grenade.visuals[variant];
		      const { mesh } = createGrenadeMesh({ ignorePlaceholders: variant === 'gltf' });
		      grenade.visuals[variant] = mesh;
		      return mesh;
		    }

		    function swapFallingCrateVisual(crate, variant) {
		      if (!crate || !crate.mesh) return;
		      crate.activeVisual = crate.activeVisual || (crate.visuals?.gltf ? 'gltf' : 'placeholder');
		      if (crate.activeVisual === variant) return;
	      const nextMesh = ensureFallingCrateVisual(crate, variant);
	      if (!nextMesh) return;

	      const oldMesh = crate.mesh;
	      const pos = oldMesh.position.clone();
	      const rot = oldMesh.rotation.clone();

	      world.scene.remove(oldMesh);
	      nextMesh.position.copy(pos);
	      nextMesh.rotation.copy(rot);
	      world.scene.add(nextMesh);

	      crate.mesh = nextMesh;
	      crate.activeVisual = variant;
	    }

	    function ensureFallingCrateVisual(crate, variant) {
	      crate.visuals = crate.visuals || { gltf: null, placeholder: null };
	      if (crate.visuals[variant]) return crate.visuals[variant];
	      const { mesh } = createCrateMesh({ ignorePlaceholders: variant === 'gltf' });
	      crate.visuals[variant] = mesh;
	      return mesh;
	    }

	    function swapArenaDecorVisual(item, variant) {
	      if (!item || !item.mesh) return;
	      item.activeVisual = item.activeVisual || (item.visuals?.gltf ? 'gltf' : 'placeholder');
	      if (item.activeVisual === variant) return;
	      const nextMesh = ensureArenaDecorVisual(item, variant);
	      if (!nextMesh) return;

	      const oldMesh = item.mesh;
	      const x = oldMesh.position.x;
	      const z = oldMesh.position.z;
	      const rotY = oldMesh.rotation.y;

	      world.scene.remove(oldMesh);
	      removeFromArray(world.arenaObjects, oldMesh);

	      const y = item.kind === 'fence'
	        ? (variant === 'gltf' ? 0 : 0.55)
	        : nextMesh.position.y;
	      nextMesh.position.set(x, y, z);
	      nextMesh.rotation.y = rotY;

	      world.scene.add(nextMesh);
	      world.arenaObjects.push(nextMesh);

	      item.mesh = nextMesh;
	      item.activeVisual = variant;
	    }

	    function ensureArenaDecorVisual(item, variant) {
	      item.visuals = item.visuals || { gltf: null, placeholder: null };
	      if (item.visuals[variant]) return item.visuals[variant];

	      if (variant === 'placeholder') {
	        if (item.kind === 'fence') {
	          const len = item.placeholderLength || (CONFIG.arena.width + 0.8);
	          const root = markPlaceholder(
	            new THREE.Mesh(
	              new THREE.BoxGeometry(len, 1.1, 0.18),
	              new THREE.MeshStandardMaterial({ color: COLORS.steel, roughness: 0.8, metalness: 0.05 })
	            )
	          );
	          root.castShadow = true;
	          root.receiveShadow = true;
	          root.position.y = 0.55;
	          item.visuals.placeholder = root;
	          return root;
	        }
	        const root = markPlaceholder(
	          new THREE.Mesh(
	            new THREE.BoxGeometry(0.9, 0.6, 0.9),
	            new THREE.MeshStandardMaterial({ color: COLORS.dustDark, roughness: 0.85, metalness: 0.05 })
	          )
	        );
	        root.castShadow = true;
	        root.receiveShadow = true;
	        root.position.y = 0.3;
	        item.visuals.placeholder = root;
	        return root;
	      }

	      const clone = cloneAsset(item.assetPath, { ignorePlaceholders: true });
	      if (!clone) return null;
	      const root = normalizeToHeight(clone.root, null);
	      root.traverse?.((child) => {
	        if (child.isMesh) {
	          child.castShadow = true;
	          child.receiveShadow = true;
	        }
	      });
	      if (item.kind === 'fence') root.scale.setScalar(1.1);
	      item.visuals.gltf = root;
	      return root;
	    }

    function computeMeshBounds(root) {
      const box = new THREE.Box3();
      root.updateMatrixWorld(true);
      root.traverse((child) => {
        if (child.isMesh && child.geometry) {
          child.geometry.computeBoundingBox();
          const childBox = child.geometry.boundingBox.clone();
          childBox.applyMatrix4(child.matrixWorld);
          box.union(childBox);
        }
      });
      return box;
    }

    function normalizeToHeight(root, targetHeight) {
      root.position.set(0, 0, 0);
      root.rotation.set(0, 0, 0);
      root.scale.set(1, 1, 1);
      root.updateMatrixWorld(true);

      const box = computeMeshBounds(root);
      if (box.isEmpty()) box.setFromObject(root);
      const size = box.getSize(new THREE.Vector3());
      if (targetHeight && size.y > 0) {
        const scale = targetHeight / size.y;
        root.scale.setScalar(scale);
        root.updateMatrixWorld(true);
      }

      const box2 = computeMeshBounds(root);
      if (box2.isEmpty()) box2.setFromObject(root);
      root.position.y -= box2.min.y;
      root.updateMatrixWorld(true);
      return root;
    }

    function findBuiltInWeapons(root) {
      const weaponMap = {
        pistol: ['pistol'],
        smg: ['smg'],
        shotgun: ['shotgun']
      };
      const otherWeaponKeywords = ['ak', 'revolver', 'knife', 'shovel', 'sniper', 'grenade', 'launcher', 'cannon', 'rocket'];
      const found = {};
      root.traverse((child) => {
        const name = (child.name || '').toLowerCase();
        // Map to game weapon IDs
        for (const [weaponId, keywords] of Object.entries(weaponMap)) {
          if (keywords.some(k => name === k || name.includes(k))) {
            found[weaponId] = child;
            child.visible = false;
            return;
          }
        }
        // Hide other weapons we don't use
        if (otherWeaponKeywords.some(k => name.includes(k))) {
          child.visible = false;
        }
      });
      return found;
    }

	    function clearArena() {
	      world.cover.forEach((cover) => {
	        if (cover.mesh) world.scene.remove(cover.mesh);
	      });
      world.barrels.forEach((barrel) => {
        if (barrel.mesh) world.scene.remove(barrel.mesh);
      });
      clearGrenades();
      world.spilledBarrels.forEach((mesh) => {
        world.scene.remove(mesh);
      });
	      world.arenaObjects.forEach((obj) => {
	        world.scene.remove(obj);
	      });
	      world.arenaDecor.forEach((item) => {
	        if (item && item.mesh) world.scene.remove(item.mesh);
	      });
	      world.cover = [];
	      world.barrels = [];
	      world.spilledBarrels = [];
	      world.nodes = [];
	      world.arenaObjects = [];
	      world.arenaDecor = [];
	      world.arenaLayout = null;
	    }

    function buildArena() {
      const manifest = assets.manifest.assets.toonshooter;
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(BASE_ARENA.ground.width * (CONFIG.arena.width / BASE_ARENA.width), BASE_ARENA.ground.depth * (CONFIG.arena.depth / BASE_ARENA.depth)),
        new THREE.MeshStandardMaterial({ color: COLORS.dust, roughness: 0.9, metalness: 0.05 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      world.scene.add(ground);
      world.arenaObjects.push(ground);

	      const border = new THREE.LineSegments(
	        new THREE.EdgesGeometry(new THREE.PlaneGeometry(CONFIG.arena.width, CONFIG.arena.depth)),
	        new THREE.LineBasicMaterial({ color: COLORS.dustDark })
	      );
	      border.rotation.x = -Math.PI / 2;
	      border.position.y = 0.02;
	      world.scene.add(border);
	      world.arenaObjects.push(border);
	      world.arenaDecor = [];

      // Main cover placements - collide-able obstacles
      const placements = [
        // Center major occluder - Tank (permanent cover)
        { key: 'Tank', pos: [0, 0, -0.6], rot: Math.PI * 0.6, collide: true },

        // Safe spawn cover (permanent)
        { key: 'Barrier_Large', pos: [-11.2, 0, -4.2], rot: Math.PI / 2, collide: true },
        { key: 'Barrier_Large', pos: [-11.2, 0, 4.2], rot: Math.PI / 2, collide: true },
        { key: 'Barrier_Large', pos: [11.2, 0, -4.2], rot: -Math.PI / 2, collide: true },
        { key: 'Barrier_Large', pos: [11.2, 0, 4.2], rot: -Math.PI / 2, collide: true },

        // Permanent lane anchors
        { key: 'SackTrench', pos: [-7.4, 0, 0.8], rot: 0, collide: true },
        { key: 'SackTrench', pos: [7.4, 0, -0.8], rot: Math.PI, collide: true },
        { key: 'Container_Small', pos: [-10.2, 0, -7.2], rot: 0.1, collide: true },
        { key: 'Container_Small', pos: [10.2, 0, 7.2], rot: -Math.PI + 0.1, collide: true },
        { key: 'Structure_1', pos: [-10.3, 0, 7.1], rot: 0, collide: true },
        { key: 'Structure_1', pos: [10.3, 0, -7.1], rot: Math.PI, collide: true },

        // Mid-map destructible cover (opens up over the match)
        { key: 'Crate', pos: [-3.2, 0, 0], rot: 0.2, collide: true },
        { key: 'Crate', pos: [3.2, 0, 0], rot: -0.2, collide: true },
        { key: 'Crate', pos: [0, 0, 5.1], rot: 0.5, collide: true },
        { key: 'Crate', pos: [0, 0, -5.1], rot: -0.4, collide: true },
        { key: 'Pallet', pos: [-6.2, 0, -1.6], rot: 0.15, collide: true },
        { key: 'Pallet', pos: [6.2, 0, 1.6], rot: -0.15, collide: true },
        { key: 'Sofa', pos: [-8.3, 0, 5.9], rot: Math.PI / 4, collide: true },
        { key: 'Sofa', pos: [8.3, 0, -5.9], rot: -Math.PI / 4, collide: true },
        { key: 'CardboardBoxes_2', pos: [-2.2, 0, -6.6], rot: 0.2, collide: true },
        { key: 'CardboardBoxes_3', pos: [2.2, 0, 6.6], rot: -0.2, collide: true }
      ];

      // Decorative props - non-colliding clutter for visual density
      const decorativePlacements = [
        // Cardboard boxes clusters scattered around
        { key: 'CardboardBoxes_1', pos: [-11, 0, 5], rot: 0.3 },
        { key: 'CardboardBoxes_2', pos: [11, 0, -5], rot: -0.4 },
        { key: 'CardboardBoxes_3', pos: [-2, 0, -7], rot: 0.1 },
        { key: 'CardboardBoxes_4', pos: [2, 0, 7], rot: -0.2 },
        { key: 'CardboardBoxes_1', pos: [5, 0, -6], rot: 0.6 },
        { key: 'CardboardBoxes_2', pos: [-5, 0, 6], rot: -0.5 },
        // Tires scattered
        { key: 'Debris_Tires', pos: [4, 0, -3], rot: 0 },
        { key: 'Debris_Tires', pos: [-4, 0, -5], rot: Math.PI / 3 },
        { key: 'Debris_Tires', pos: [8, 0, 2], rot: 0.8 },
        // Traffic cones marking areas
        { key: 'TrafficCone', pos: [-2, 0, -2], rot: 0 },
        { key: 'TrafficCone', pos: [2, 0, 2], rot: 0 },
        { key: 'TrafficCone', pos: [-9, 0, 0], rot: 0.2 },
        { key: 'TrafficCone', pos: [9, 0, 0], rot: -0.1 },
        { key: 'TrafficCone', pos: [0, 0, -8], rot: 0.3 },
        { key: 'TrafficCone', pos: [0, 0, 8], rot: -0.2 },
        // Debris piles
        { key: 'Debris_Pile', pos: [-10, 0, 2], rot: 0.5 },
        { key: 'Debris_Pile', pos: [10, 0, -2], rot: -0.3 },
        { key: 'Debris_Pile', pos: [3, 0, -4], rot: 0.7 },
        // Paper debris scattered
        { key: 'Debris_Papers_1', pos: [-1, 0, -3], rot: 0.8 },
        { key: 'Debris_Papers_2', pos: [1, 0, 3], rot: -0.6 },
        { key: 'Debris_Papers_3', pos: [-6, 0, -2], rot: 0.4 },
        // Gas cans
        { key: 'GasCan', pos: [-7, 0, -4], rot: 0.2 },
        { key: 'GasCan', pos: [7, 0, 4], rot: -0.3 },
        // Wood planks
        { key: 'WoodPlanks', pos: [-3, 0, 4], rot: 0.6 },
        { key: 'WoodPlanks', pos: [3, 0, -4], rot: -0.5 },
        // Broken pallets
        { key: 'Pallet_Broken', pos: [9, 0, -4], rot: 0.3 },
        { key: 'Pallet_Broken', pos: [-9, 0, 4], rot: -0.4 },
        // Pipes near edges
        { key: 'Pipes', pos: [-12, 0, 0], rot: Math.PI / 2 },
        { key: 'Pipes', pos: [12, 0, 0], rot: -Math.PI / 2 },
        // Trash containers at edges
        { key: 'TrashContainer', pos: [-12, 0, -6], rot: 0.1 },
        { key: 'TrashContainer_Open', pos: [12, 0, 6], rot: -0.1 },
        // Street lights for atmosphere
        { key: 'StreetLight', pos: [-12, 0, 4], rot: 0 },
        { key: 'StreetLight', pos: [12, 0, -4], rot: Math.PI },
        // Signs
        { key: 'Sign', pos: [-11, 0, 7], rot: -0.2 },
        { key: 'Sign', pos: [11, 0, -7], rot: 0.3 }
      ];

      const fallbackSizes = {
        Tank: [4.5, 2.5, 3.0],
        Debris_BrokenCar: [3.5, 1.5, 2.0],
        Container_Small: [4.2, 2.0, 2.2],
        Barrier_Large: [3.6, 1.2, 1.2],
        Crate: [1.2, 1.2, 1.2],
        SackTrench: [2.4, 0.8, 1.2],
        Sofa: [2.0, 1.0, 1.0],
        Structure_1: [2.5, 2.0, 2.5],
        Pallet: [1.4, 0.2, 1.4],
        CardboardBoxes_1: [1.1, 0.8, 1.1],
        CardboardBoxes_2: [1.1, 0.8, 1.1],
        CardboardBoxes_3: [1.1, 0.8, 1.1],
        CardboardBoxes_4: [1.1, 0.8, 1.1]
      };

      // Place colliding cover
	      placements.forEach((item) => {
	        const path = manifest.environment[item.key];
	        const clone = cloneAsset(path);
	        const isFallback = !clone;
	        const activeVisual = isFallback ? 'placeholder' : 'gltf';
	        const visuals = { gltf: null, placeholder: null };
	        const fbSize = fallbackSizes[item.key] || [2, 1.5, 2];
	        const root = isFallback
	          ? new THREE.Mesh(
	            new THREE.BoxGeometry(...fbSize),
	            new THREE.MeshStandardMaterial({ color: COLORS.steel, roughness: 0.7, metalness: 0.1 })
	          )
	          : normalizeToHeight(clone.root, null);
	        if (isFallback) root.position.y = fbSize[1] / 2;
	        visuals[activeVisual] = isFallback ? markPlaceholder(root) : root;
	        root.position.set(item.pos[0], root.position.y, item.pos[2]);
	        root.rotation.y = item.rot;
	        root.traverse?.((child) => {
	          if (child.isMesh) {
	            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        world.scene.add(root);
        world.arenaObjects.push(root);

	        if (item.collide !== false) {
	          const box = computeMeshBounds(root);
	          const inset = 0.08;
		          const typeCfg = CONFIG.cover.types[item.key] || null;
		          const cover = {
	            key: item.key,
	            assetPath: path,
	            mesh: root,
	            visuals,
	            activeVisual,
	            spawnPos: root.position.clone(),
	            spawnRotY: root.rotation.y,
		            minX: box.min.x + inset,
		            maxX: box.max.x - inset,
		            minZ: box.min.z + inset,
	            maxZ: box.max.z - inset,
	            minY: box.min.y,
	            maxY: box.max.y,
	            blocksLoS: true,
	            active: true,
	            destructible: Boolean(typeCfg),
            hp: typeCfg ? typeCfg.hp : null,
            maxHp: typeCfg ? typeCfg.hp : null,
            kickable: Boolean(typeCfg),
            flashTimer: 0,
            originalMaterials: null,
            colliderOffsets: null,
            kickState: null
          };
          cacheCoverColliderOffsets(cover);
          world.cover.push(cover);
        }
      });

	      // Place decorative (non-colliding) props
	      decorativePlacements.forEach((item) => {
	        const path = manifest.environment[item.key];
	        if (!path) return; // Skip if asset doesn't exist
	        const clone = cloneAsset(path);
	        const activeVisual = clone ? 'gltf' : 'placeholder';
	        const visuals = { gltf: null, placeholder: null };
	        const root = clone
	          ? normalizeToHeight(clone.root, null)
	          : markPlaceholder(
	            new THREE.Mesh(
	              new THREE.BoxGeometry(0.9, 0.6, 0.9),
	              new THREE.MeshStandardMaterial({ color: COLORS.dustDark, roughness: 0.85, metalness: 0.05 })
	            )
	          );
	        visuals[activeVisual] = root;
	        root.position.set(item.pos[0], root.position.y, item.pos[2]);
	        root.rotation.y = item.rot;
	        root.traverse?.((child) => {
	          if (child.isMesh) {
	            child.castShadow = true;
	            child.receiveShadow = true;
	          }
	        });
	        world.scene.add(root);
	        world.arenaObjects.push(root);
	        world.arenaDecor.push({ kind: 'prop', key: item.key, assetPath: path, mesh: root, visuals, activeVisual });
	      });

	      const fencePath = manifest.environment.Fence_Long;
	      const fenceClone = cloneAsset(fencePath);
	      const fenceSegments = [
	        { pos: [0, 0, CONFIG.arena.bounds.minZ - 0.4], rot: 0, len: CONFIG.arena.width + 0.8 },
	        { pos: [0, 0, CONFIG.arena.bounds.maxZ + 0.4], rot: Math.PI, len: CONFIG.arena.width + 0.8 },
	        { pos: [CONFIG.arena.bounds.minX - 0.4, 0, 0], rot: Math.PI / 2, len: CONFIG.arena.depth + 0.8 },
	        { pos: [CONFIG.arena.bounds.maxX + 0.4, 0, 0], rot: -Math.PI / 2, len: CONFIG.arena.depth + 0.8 }
	      ];
	      const fenceModel = fenceClone ? normalizeToHeight(fenceClone.root, null) : null;
	      fenceSegments.forEach((seg) => {
	        const cloneFence = fenceModel ? fenceModel.clone(true) : null;
	        const activeVisual = cloneFence ? 'gltf' : 'placeholder';
	        const visuals = { gltf: null, placeholder: null };
	        const fence = cloneFence
	          ? cloneFence
	          : markPlaceholder(
	            new THREE.Mesh(
	              new THREE.BoxGeometry(seg.len, 1.1, 0.18),
	              new THREE.MeshStandardMaterial({ color: COLORS.steel, roughness: 0.8, metalness: 0.05 })
	            )
	          );
	        visuals[activeVisual] = fence;
	        if (cloneFence) {
	          fence.position.set(seg.pos[0], 0, seg.pos[2]);
	        } else {
	          fence.position.set(seg.pos[0], 0.55, seg.pos[2]);
	        }
	        fence.rotation.y = seg.rot;
	        fence.scale.setScalar(1.1);
	        world.scene.add(fence);
	        world.arenaObjects.push(fence);
	        world.arenaDecor.push({
	          kind: 'fence',
	          key: 'Fence_Long',
	          assetPath: fencePath,
	          mesh: fence,
	          visuals,
	          activeVisual,
	          placeholderLength: seg.len
	        });
	      });

	      world.arenaLayout = { decorativePlacements, fallbackSizes, fenceSegments };

	      spawnBarrels();

	      buildCoverNodes();
	    }

    function cacheCoverColliderOffsets(cover) {
      if (!cover.mesh) return;
      const box = computeMeshBounds(cover.mesh);
      cover.colliderOffsets = {
        minX: cover.minX - cover.mesh.position.x,
        maxX: cover.maxX - cover.mesh.position.x,
        minZ: cover.minZ - cover.mesh.position.z,
        maxZ: cover.maxZ - cover.mesh.position.z,
        minY: box.min.y - cover.mesh.position.y,
        maxY: box.max.y - cover.mesh.position.y
      };
      cover.minY = box.min.y;
      cover.maxY = box.max.y;
    }

    function syncCoverColliderFromMesh(cover) {
      if (!cover.mesh || !cover.colliderOffsets) return;
      cover.minX = cover.mesh.position.x + cover.colliderOffsets.minX;
      cover.maxX = cover.mesh.position.x + cover.colliderOffsets.maxX;
      cover.minZ = cover.mesh.position.z + cover.colliderOffsets.minZ;
      cover.maxZ = cover.mesh.position.z + cover.colliderOffsets.maxZ;
      if (typeof cover.colliderOffsets.minY === 'number') {
        cover.minY = cover.mesh.position.y + cover.colliderOffsets.minY;
      }
      if (typeof cover.colliderOffsets.maxY === 'number') {
        cover.maxY = cover.mesh.position.y + cover.colliderOffsets.maxY;
      }
    }

    function spawnBarrels() {
      const manifest = assets.manifest.assets.toonshooter;
      const barrelPath = manifest.environment.ExplodingBarrel;
      const barrelClone = cloneAsset(barrelPath);
      const barrelPositions = [
        new THREE.Vector3(-8.2, 0, -6.5),
        new THREE.Vector3(8.2, 0, 6.5),
        new THREE.Vector3(0, 0, 7.0)
      ];

	      barrelPositions.forEach((pos) => {
	        const barrelRoot = barrelClone ? normalizeToHeight(barrelClone.root.clone(true), null) : null;
	        const fallback = new THREE.Mesh(
	          new THREE.CylinderGeometry(0.45, 0.45, 1.2, 12),
	          new THREE.MeshStandardMaterial({ color: COLORS.warning, roughness: 0.4, metalness: 0.2 })
	        );
	        const mesh = barrelRoot || fallback;
	        const activeVisual = barrelRoot ? 'gltf' : 'placeholder';
	        const visuals = { gltf: null, placeholder: null };
	        mesh.position.copy(pos);
	        if (!barrelRoot) mesh.position.y = 0.6;
	        if (!barrelRoot) markPlaceholder(mesh);
	        visuals[activeVisual] = mesh;
	        mesh.castShadow = true;
	        mesh.receiveShadow = true;
	        world.scene.add(mesh);
	        world.barrels.push({
	          assetPath: barrelPath,
	          mesh,
	          position: mesh.position,
	          visuals,
	          activeVisual,
	          spawnPos: pos.clone(),
	          velocity: new THREE.Vector3(),
	          hp: CONFIG.barrel.hp,
	          alive: true,
          radius: CONFIG.barrel.radius,
          isRolling: false,
          rollTimer: 0
        });
      });
    }

    function buildCoverNodes() {
      world.nodes = [];
      const offset = 1.1;
      world.cover.forEach((box) => {
        if (box.active === false) return;
        const cx = (box.minX + box.maxX) / 2;
        const cz = (box.minZ + box.maxZ) / 2;
        const hx = (box.maxX - box.minX) / 2 + offset;
        const hz = (box.maxZ - box.minZ) / 2 + offset;
        addNode(cx + hx, cz);
        addNode(cx - hx, cz);
        addNode(cx, cz + hz);
        addNode(cx, cz - hz);
      });

      addNode(-8, 0);
      addNode(8, 0);
      addNode(0, -7);
      addNode(0, 7);

      function addNode(x, z) {
        if (x < CONFIG.arena.bounds.minX + 1 || x > CONFIG.arena.bounds.maxX - 1) return;
        if (z < CONFIG.arena.bounds.minZ + 1 || z > CONFIG.arena.bounds.maxZ - 1) return;
        world.nodes.push(new THREE.Vector3(x, 0, z));
      }
    }

    function spawnEntities() {
      const manifest = assets.manifest.assets.toonshooter;
      const playerPath = manifest.characters.Character_Soldier;
      const enemyPath = manifest.characters.Character_Enemy;
      const guns = {
        pistol: manifest.guns.Pistol,
        smg: manifest.guns.SMG,
        shotgun: manifest.guns.Shotgun
      };
      const mode = getActiveGameMode();
      const spawnPoints = getSpawnPoints(mode.playerCount);
      const roster = [
        { id: 'p1', name: 'Player 1 (Green)', team: 'p1', color: COLORS.p1, path: playerPath, isPlayer: true },
        { id: 'p2', name: 'Player 2 (Red)', team: 'p2', color: COLORS.p2, path: enemyPath, isPlayer: false },
        { id: 'p3', name: 'Player 3 (Blue)', team: 'p3', color: COLORS.p3, path: enemyPath, isPlayer: false },
        { id: 'p4', name: 'Player 4 (Gold)', team: 'p4', color: COLORS.p4, path: enemyPath, isPlayer: false }
      ];

      roster.slice(0, mode.playerCount).forEach((entry, index) => {
        const entity = createCharacter({
          id: entry.id,
          path: entry.path,
          guns,
          team: entry.team,
          color: entry.color,
          spawn: spawnPoints[index]
        });
        entity.displayName = entry.name;
        entity.isPlayer = entry.isPlayer;
        entity.spawnPoint = spawnPoints[index].clone();
        if (!entry.isPlayer) {
          entity.isAI = true;
          entity.ai = {
            thinkTimer: 0.8, // Delay before AI starts thinking
            strafeDir: 1,
            targetNode: null,
            lastHitTime: -999,
            dashBias: 0,
            burstCount: 0, // Track shots in current burst
            burstCooldown: 0, // Pause between bursts
            desiredMove: null,
            fireIntent: false
          };
        }
        world.entities.push(entity);
      });
    }

    function clearEntities() {
      world.entities.forEach((entity) => {
        if (entity.muzzle) world.scene.remove(entity.muzzle);
        if (entity.group) world.scene.remove(entity.group);
      });
      world.entities = [];
      world.mixers = [];
    }

    function getSpawnPoints(count) {
      return SPAWN_POINTS.slice(0, count).map((point) => point.clone());
    }

	    function createCharacter({ id, path, guns, team, color, spawn }) {
	      const clone = cloneAsset(path);
	      let root;
	      if (clone) {
	        root = normalizeToHeight(clone.root, CONFIG.player.height);
      } else {
        root = new THREE.Mesh(
          new THREE.CapsuleGeometry(0.35, 1.2, 6, 12),
          new THREE.MeshStandardMaterial({ color })
        );
      }
      root.traverse?.((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      const gunMeshes = findBuiltInWeapons(root);

      const group = new THREE.Group();
      group.add(root);
      group.position.copy(spawn);

      const ring = new THREE.Mesh(
        new THREE.RingGeometry(0.45, 0.6, 24),
        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 })
      );
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = 0.02;
      group.add(ring);

      const muzzle = createSprite(0xffffff, 0.3);
      muzzle.visible = false;
      world.scene.add(muzzle); // Add to scene (world space) not group (local space)

      world.scene.add(group);

	      const entity = {
	        id,
	        assetPath: path,
	        color,
	        team,
	        group,
	        root,
	        position: group.position,
        velocity: new THREE.Vector3(),
        yaw: 0,
        hp: 100,
        weapon: createWeaponLoadout(),
        fireCooldown: 0,
        firedRecentlyTimer: 0,
        dashTimer: 0,
        dashCooldown: 0,
	        kickCooldown: 0,
	        stunTimer: 0,
	        nearMissCooldown: 0,
	        grenadeAmmo: CONFIG.grenade.ammoStart,
	        grenadeCooldown: 0,
	        stunTilt: 0,
		        isDead: false,
		        guns: gunMeshes,
		        muzzle,
		        mixers: setupAnimations(root, clone ? clone.animations : []),
	        visuals: (() => {
	          const active = clone ? 'gltf' : 'placeholder';
	          const visuals = { gltf: null, placeholder: null };
	          visuals[active] = root;
	          return visuals;
	        })(),
	        activeVisual: clone ? 'gltf' : 'placeholder',
	        visualAnimations: {
	          gltf: clone ? (clone.animations || []) : [],
	          placeholder: []
	        },
	        // Match stats for tracking performance
	        matchStats: {
	          kills: 0,
	          deaths: 0,
	          damageDealt: 0,
	          damageTaken: 0,
	          shotsFired: 0,
	          shotsHit: 0,
	          grenadesThrown: 0,
	          powerupsCollected: 0,
	          nearMisses: 0
	        },
	        // Power-up effects
	        buffs: {
	          speedMul: 1,
	          damageMul: 1,
	          speedTimer: 0,
	          damageTimer: 0
	        },
	        shield: 0
	      };

      syncWeaponVisibility(entity);
      return entity;
    }

    function createWeaponLoadout() {
      const states = {};
      Object.keys(CONFIG.weapons).forEach((weaponId) => {
        const weapon = CONFIG.weapons[weaponId];
        const unlocked = weaponId === 'pistol';
        const reserveStart = Math.min(weapon.reserveStart || 0, weapon.reserveMax || 0);
        states[weaponId] = {
          ammo: unlocked ? weapon.magSize : 0,
          reserve: unlocked ? reserveStart : 0,
          reloadTimer: 0,
          unlocked
        };
      });
      return {
        id: 'pistol',
        pending: null,
        switchTimer: 0,
        states
      };
    }

    function getWeaponConfig(weaponId) {
      return CONFIG.weapons[weaponId];
    }

    function getActiveWeaponConfig(entity) {
      return getWeaponConfig(entity.weapon.id);
    }

    function getWeaponState(entity, weaponId = entity.weapon.id) {
      return entity.weapon.states[weaponId];
    }

    function canUseWeapon(entity, weaponId) {
      const state = getWeaponState(entity, weaponId);
      return Boolean(state && state.unlocked && (state.ammo > 0 || state.reserve > 0));
    }

    function syncWeaponVisibility(entity) {
      if (!entity.guns) return;
      Object.entries(entity.guns).forEach(([weaponId, gun]) => {
        if (!gun) return;
        gun.visible = weaponId === entity.weapon.id;
      });
    }

    function requestWeaponSwitch(entity, weaponId) {
      if (!entity || entity.isDead) return;
      if (!CONFIG.weapons[weaponId]) return;
      if (entity.weapon.switchTimer > 0) return;
      if (entity.weapon.id === weaponId) return;
      const nextState = getWeaponState(entity, weaponId);
      if (!nextState || !nextState.unlocked) return;
      if (nextState.ammo <= 0 && nextState.reserve <= 0) return;
      entity.weapon.pending = weaponId;
      entity.weapon.switchTimer = CONFIG.weaponSwitch.duration;
      entity.fireCooldown = Math.max(entity.fireCooldown, 0.05);
      fx.fovPulse = Math.max(fx.fovPulse, 0.3);
    }

    function updateWeaponSwitch(entity, dt) {
      if (entity.weapon.switchTimer <= 0) return;
      entity.weapon.switchTimer -= dt;
      if (entity.weapon.switchTimer <= 0 && entity.weapon.pending) {
        entity.weapon.id = entity.weapon.pending;
        entity.weapon.pending = null;
        syncWeaponVisibility(entity);
      }
    }

    function setupAnimations(root, animations) {
      if (!animations || animations.length === 0) return null;
      const mixer = new THREE.AnimationMixer(root);
      const findClip = (tokens) => animations.find(clip => tokens.some(t => clip.name.toLowerCase().includes(t)));
      const idle = findClip(['idle', 'stand', 'breathe']) || animations[0];
      const run = findClip(['run', 'walk', 'move']) || idle;
      const shoot = findClip(['shoot', 'fire', 'attack']) || null;
      const reload = findClip(['reload', 'reloading']) || null;
      const death = findClip(['death', 'die', 'dead']) || null;
      const hit = findClip(['hit', 'hurt', 'stun', 'fall', 'knock', 'impact', 'flinch']) || death || null;
      const actions = {
        idle: idle ? mixer.clipAction(idle) : null,
        run: run ? mixer.clipAction(run) : null,
        shoot: shoot ? mixer.clipAction(shoot) : null,
        reload: reload ? mixer.clipAction(reload) : null,
        hit: hit ? mixer.clipAction(hit) : null,
        death: death ? mixer.clipAction(death) : null
      };
      if (actions.idle) actions.idle.play();
      const entry = { mixer, actions, current: 'idle' };
      if (actions.shoot) {
        actions.shoot.clampWhenFinished = false;
        actions.shoot.setLoop(THREE.LoopOnce, 1);
        actions.shoot.enabled = true;
        actions.shoot.setEffectiveWeight(1);
        actions.shoot.setEffectiveTimeScale(1.4);
      }
      if (actions.death) {
        actions.death.clampWhenFinished = true;
        actions.death.setLoop(THREE.LoopOnce, 1);
        actions.death.enabled = true;
        actions.death.setEffectiveWeight(1);
      }
      if (actions.reload) {
        actions.reload.clampWhenFinished = false;
        actions.reload.setLoop(THREE.LoopRepeat, Infinity);
        actions.reload.enabled = true;
        actions.reload.setEffectiveWeight(1);
      }
      if (actions.hit) {
        actions.hit.clampWhenFinished = true;
        actions.hit.setLoop(THREE.LoopOnce, 1);
        actions.hit.enabled = true;
        actions.hit.setEffectiveWeight(1);
      }
      world.mixers.push(entry);
      return entry;
    }

    function setupHUD() {
      buildPlayerPanels();
      updateRoundPips();
      updateBestTimeUI();
      updateHUD();
    }

    function buildPlayerPanels() {
      if (!playerPanelsEl) return;
      playerPanelsEl.innerHTML = '';
      hudPanels.clear();
      const mode = getActiveGameMode();
      const positions = mode.playerCount > 2
        ? ['tl', 'tr', 'bl', 'br']
        : ['tl', 'tr'];
      world.entities.forEach((entity, index) => {
        const panel = document.createElement('div');
        panel.className = `panel playerPanel pos-${positions[index] || 'tl'}${mode.playerCount > 2 ? ' compact' : ''}`;

        const nameTag = document.createElement('div');
        nameTag.className = `nameTag ${entity.team}`;
        nameTag.textContent = entity.displayName || `Player ${index + 1}`;
        panel.appendChild(nameTag);

        const kdStats = document.createElement('div');
        kdStats.className = 'kdStats';
        const kills = document.createElement('span');
        kills.className = 'kills';
        kills.textContent = 'K: 0';
        const deaths = document.createElement('span');
        deaths.className = 'deaths';
        deaths.textContent = 'D: 0';
        kdStats.append(kills, document.createTextNode(' | '), deaths);
        panel.appendChild(kdStats);

        const livesInfo = document.createElement('div');
        livesInfo.className = 'livesInfo';
        livesInfo.textContent = 'Lives: -';
        panel.appendChild(livesInfo);

        const hpWrap = document.createElement('div');
        hpWrap.className = 'hpWrap';
        const hpLabel = document.createElement('div');
        hpLabel.className = 'hpLabel';
        hpLabel.textContent = 'Health';
        const hpBar = document.createElement('div');
        hpBar.className = 'hpBar';
        for (let i = 0; i < 10; i++) {
          const seg = document.createElement('span');
          seg.className = 'hpSeg';
          hpBar.appendChild(seg);
        }
        const shieldBar = document.createElement('div');
        shieldBar.className = 'shieldBar';
        const shieldFill = document.createElement('div');
        shieldFill.className = 'shieldFill';
        shieldFill.style.width = '0%';
        shieldBar.appendChild(shieldFill);

        hpWrap.appendChild(hpLabel);
        hpWrap.appendChild(hpBar);
        hpWrap.appendChild(shieldBar);
        panel.appendChild(hpWrap);

        const weaponInfo = document.createElement('div');
        weaponInfo.className = 'weaponInfo';
        const weaponIcon = document.createElement('span');
        weaponIcon.className = 'weaponIcon';
        const weaponName = document.createElement('span');
        weaponName.className = 'weaponName';
        const weaponAmmo = document.createElement('span');
        weaponAmmo.className = 'weaponAmmo';
        const weaponReserve = document.createElement('span');
        weaponReserve.className = 'weaponReserve';
        weaponInfo.append(weaponIcon, weaponName, weaponAmmo, weaponReserve);
        panel.appendChild(weaponInfo);

        const buffRow = document.createElement('div');
        buffRow.className = 'buffRow';
        panel.appendChild(buffRow);

        playerPanelsEl.appendChild(panel);
        hudPanels.set(entity.id, { 
          panel, hpBar, shieldFill, livesInfo, weaponInfo, 
          weaponIcon, weaponName, weaponAmmo, weaponReserve,
          kills, deaths, buffRow 
        });
      });
    }

    function updateBestTimeUI() {
      const bestText = `Best win time: ${formatTime(state.bestWinTime)}`;
      bestTimeEl.textContent = bestText;
      bestTimeEnd.textContent = bestText;
    }

	    function setupMenuModes() {
	      modeButtons.forEach((button) => {
	        button.addEventListener('click', () => {
	          setGameMode(button.dataset.mode);
	        });
	      });
	      setupDifficultySelect();
	      setGameMode(state.gameMode);
	    }

	    function setupDifficultySelect() {
	      if (!difficultyButtons.length) return;
	      difficultyButtons.forEach((button) => {
	        button.addEventListener('click', () => {
	          const diff = button.dataset.diff;
	          if (!diff) return;
	          setDifficultyForMode(state.gameMode, diff);
	        });
	      });
	      updateDifficultyUI();
	    }

	    function getDifficultyForMode(modeId) {
	      const byMode = CONFIG.difficulty?.byMode || {};
	      return byMode[modeId] || 'normal';
	    }

	    function setDifficultyForMode(modeId, difficulty) {
	      if (!modeId) return;
	      const allowed = ['easy', 'normal', 'hard'];
	      if (!allowed.includes(difficulty)) return;
	      CONFIG.difficulty.byMode[modeId] = difficulty;
	      localStorage.setItem('tinyToonDuel_aiDifficultyByMode', JSON.stringify(CONFIG.difficulty.byMode));
	      updateDifficultyUI();
	    }

	    function updateDifficultyUI() {
	      const current = getDifficultyForMode(state.gameMode);
	      difficultyButtons.forEach((button) => {
	        button.classList.toggle('active', button.dataset.diff === current);
	      });
	      if (difficultyLabelEl) {
	        const modeName = CONFIG.gameModes?.[state.gameMode]?.name || state.gameMode;
	        const label = current.toUpperCase();
	        difficultyLabelEl.textContent = `${modeName} AI: ${label}`;
	      }
	    }

	    function setGameMode(modeId) {
	      if (!CONFIG.gameModes[modeId]) return;
	      state.gameMode = modeId;
	      modeButtons.forEach((button) => {
	        button.classList.toggle('active', button.dataset.mode === modeId);
	      });
	      updateMenuModeCopy();
	      updateDifficultyUI();
	    }

    function updateMenuModeCopy() {
      if (!modeSubtitleEl || !modeRulesEl) return;
      if (state.gameMode === 'deathmatch') {
        const dm = CONFIG.gameModes.deathmatch;
        modeSubtitleEl.textContent = 'Chaotic 4-player free-for-all with limited lives.';
        modeRulesEl.textContent = `${dm.playerCount} players · ${dm.lives} lives · 1:45 time limit · Barrels hurt everyone`;
      } else {
        modeSubtitleEl.textContent = 'Fast, tight 1v1 duel in a tiny arena.';
        modeRulesEl.textContent = 'Best of 5 · 1:45 time limit · Barrels hurt both players';
      }
    }

    function getActiveGameMode() {
      return CONFIG.gameModes[state.activeGameMode || state.gameMode] || CONFIG.gameModes.duel;
    }

    function applyGameMode(modeId) {
      const mode = CONFIG.gameModes[modeId] || CONFIG.gameModes.duel;
      state.activeGameMode = modeId;
      hud.dataset.gamemode = modeId;

      const scale = mode.arenaScale ?? 1;
      CONFIG.arena.width = BASE_ARENA.width * scale;
      CONFIG.arena.depth = BASE_ARENA.depth * scale;
      CONFIG.arena.bounds = {
        minX: BASE_ARENA.bounds.minX * scale,
        maxX: BASE_ARENA.bounds.maxX * scale,
        minZ: BASE_ARENA.bounds.minZ * scale,
        maxZ: BASE_ARENA.bounds.maxZ * scale
      };

      clearArena();
      clearEntities();
      clearPickups();
      buildArena();
      spawnEntities();
      setupHUD();
    }

    function setMode(mode) {
      state.mode = mode;
      hud.dataset.mode = mode;
      menuOverlay.classList.toggle('visible', mode === 'menu');
      pauseOverlay.classList.toggle('visible', mode === 'paused');
      matchOverlay.classList.toggle('visible', mode === 'matchOver');
      if (mode === 'menu') {
        bannerEl.classList.remove('show');
        suddenDeathEl.classList.remove('show');
      }
    }

    function startMatch() {
      if (state.activeGameMode !== state.gameMode) {
        applyGameMode(state.gameMode);
      }
      const mode = getActiveGameMode();
      state.wins.p1 = 0;
      state.wins.p2 = 0;
      state.round = 1;
      state.roundResults = [];
      state.timeLeft = CONFIG.match.totalTime;
      state.lives = {};
      state.suddenDeath = false;
      state.matchEnded = false;
      state.roundEnding = false;
      state.lastKill = null;
      state.killCam = null;
      killCamTextEl.classList.remove('show');
      suddenDeathEl.classList.remove('show');
      state.matchStartTime = performance.now();
      world.entities.forEach((entity) => {
        entity.lives = mode.lives || 1;
        entity.eliminated = false;
        entity.respawnTimer = 0;
      });
	      resetEntities();
	      resetBarrels();
	      resetCover();
	      clearPickups();
	      clearGrenades();
	      initPowerups();
	      world.skyDropTimer = CONFIG.pickups.skyDropInterval;
	      updateRoundPips();
	      setMode('roundIntro');
      showBanner(state.gameMode === 'deathmatch' ? 'FREE FOR ALL · FIGHT!' : `ROUND ${state.round} · FIGHT!`);
      AudioManager.playRoundStart();
      setTimeout(() => {
        if (state.mode === 'roundIntro') {
          setMode('playing');
        }
      }, 1000);
    }

    function resetEntities() {
      const mode = getActiveGameMode();
      const spawns = getSpawnPoints(mode.playerCount);
      world.entities.forEach((entity, index) => {
        const spawn = entity.spawnPoint || spawns[index] || new THREE.Vector3(0, 0, 0);
        resetEntity(entity, spawn);
      });
    }

    function resetEntity(entity, spawn) {
      if (!entity) return;
      entity.position.copy(spawn);
      entity.velocity.set(0, 0, 0);
      entity.group.rotation.x = 0;
      entity.stunTilt = 0;
      if (entity.isAI) {
        entity.hp = getModeDifficultyPreset(state.gameMode).aiHp;
      } else {
        entity.hp = 100;
      }
      entity.weapon = createWeaponLoadout();
      syncWeaponVisibility(entity);
      entity.fireCooldown = 0;
      entity.firedRecentlyTimer = 0;
      entity.dashTimer = 0;
      entity.dashCooldown = 0;
	      entity.kickCooldown = 0;
	      entity.stunTimer = 0;
	      entity.nearMissCooldown = 0;
	      entity.grenadeAmmo = CONFIG.grenade.ammoStart;
	      entity.grenadeCooldown = 0;
	      entity.isDead = false;
	      entity.eliminated = false;
	      entity.respawnTimer = 0;
      // Reset animation to idle
      resetAnimationToIdle(entity);
      if (entity.ai) {
        entity.ai.thinkTimer = 0.8; // Delay before AI starts thinking (gives idle animation time)
        entity.ai.strafeDir = 1;
        entity.ai.targetNode = null;
        entity.ai.lastHitTime = -999;
        entity.ai.burstCount = 0;
        entity.ai.burstCooldown = 0;
        entity.ai.desiredMove = null; // Clear any previous move intent
        entity.ai.fireIntent = false; // Don't fire immediately
      }
    }

    function resetAnimationToIdle(entity) {
      const mixerEntry = entity.mixers;
      if (!mixerEntry) return;
      // Stop all animations
      Object.values(mixerEntry.actions).forEach(action => {
        if (action) {
          action.stop();
        }
      });
      // Start idle
      if (mixerEntry.actions.idle) {
        mixerEntry.actions.idle.reset();
        mixerEntry.actions.idle.play();
      }
      mixerEntry.current = 'idle';
    }

    function resetBarrels() {
      // First, remove all spilled barrel meshes from the scene
      world.spilledBarrels.forEach((mesh) => {
        world.scene.remove(mesh);
        // Dispose of geometry and materials to free memory
        mesh.traverse?.((child) => {
          if (child.isMesh) {
            child.geometry?.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(m => m.dispose());
              } else {
                child.material.dispose();
              }
            }
          }
        });
      });
      world.spilledBarrels = [];

      // Clean up any remaining particles
      world.fxParticles.forEach((particle) => {
        world.scene.remove(particle);
        particle.geometry?.dispose();
        particle.material?.dispose();
      });
      world.fxParticles = [];

      // Reset all barrels to their initial state
      world.barrels.forEach((barrel) => {
        barrel.hp = CONFIG.barrel.hp;
        barrel.alive = true;
        barrel.mesh.visible = true;
        if (barrel.spawnPos) barrel.position.copy(barrel.spawnPos);
        barrel.velocity?.set(0, 0, 0);
        barrel.isRolling = false;
        barrel.rollTimer = 0;
        barrel.lastDamagedByTeam = null;
        barrel.spilledMesh = null; // Clear the spilled mesh reference
      });
    }

    function resetCover() {
      world.cover.forEach((cover) => {
        if (!cover.destructible) return;
        cover.hp = cover.maxHp;
        cover.active = true;
        cover.kickState = null;
        cover.flashTimer = 0;
        if (cover.originalMaterials) {
          cover.originalMaterials.forEach(({ mesh, material }) => {
            mesh.material = material;
          });
        }
        if (cover.mesh) {
          cover.mesh.visible = true;
          if (cover.spawnPos) cover.mesh.position.copy(cover.spawnPos);
          if (typeof cover.spawnRotY === 'number') cover.mesh.rotation.y = cover.spawnRotY;
        }
        syncCoverColliderFromMesh(cover);
      });
      buildCoverNodes();
    }

    function animate() {
      requestAnimationFrame(animate);
      const rawDt = world.clock.getDelta();
      updateFxTimers(rawDt);

      if (state.mode === 'killCam') {
        updateKillCam(rawDt);
      } else if (state.mode === 'playing') {
        updateGame(rawDt);
      } else if (state.mode === 'menu') {
        updateIdle(rawDt);
      }

      const simDt = rawDt * getSimTimeScale();
      updateMixers(simDt);
      updateTracers(simDt);
      updateSprites(simDt);
      updateParticles(simDt);
      updateCameraFx(rawDt);
      input.mouse.justPressed = false;
      world.renderer.render(world.scene, world.camera);
    }

    function updateFxTimers(dt) {
      if (fx.hitFlashTimer > 0) {
        fx.hitFlashTimer -= dt;
        hitFlash.style.opacity = fx.hitFlashTimer > 0 ? '1' : '0';
      }
      if (fx.nearMissTimer > 0) {
        fx.nearMissTimer -= dt;
        nearMissFlash.style.opacity = fx.nearMissTimer > 0 ? '1' : '0';
      }
      if (fx.dramaticTimer > 0) {
        fx.dramaticTimer -= dt;
        dramaticOverlay.style.opacity = fx.dramaticTimer > 0 ? '1' : '0';
      } else {
        fx.dramaticTeam = null;
        dramaticOverlay.style.opacity = '0';
      }
      if (fx.timeScaleTimer > 0) {
        fx.timeScaleTimer -= dt;
        if (fx.timeScaleTimer <= 0) fx.timeScale = 1;
      }
      if (fx.hitstopTimer > 0) {
        fx.hitstopTimer -= dt;
      }
    }

    function getModeDifficultyPreset(modeId) {
      const key = getDifficultyForMode(modeId);
      const presets = CONFIG.difficulty?.presets || {};
      return presets[key] || presets.normal || {
        aiHp: 100,
        aiDamageMul: 1,
        aiFireRateMul: 1,
        aiSpreadMul: 1,
        aiThinkBase: 0.35,
        aiThinkJitter: 0.3
      };
    }

    function getAiTuning(entity) {
      if (!entity || !entity.isAI) return null;
      return getModeDifficultyPreset(state.gameMode);
    }

    function updateGame(dt) {
      const scaledDt = fx.hitstopTimer > 0 ? 0 : dt * fx.timeScale;

      updateTimer(scaledDt);
      updateSkyDrops(scaledDt);
      updateFallingCrates(scaledDt);
	      updatePickups(scaledDt);
	      updatePowerups(scaledDt);
	      updateRollingBarrels(scaledDt);
	      updateCoverStates(scaledDt);
	      updateGrenades(scaledDt);
      world.entities.forEach((entity) => {
        if (!entity || entity.eliminated) return;
        if (entity.isAI) {
          updateAI(entity, scaledDt);
        } else {
          updatePlayer(entity, scaledDt);
        }
        updateStunVisual(entity, dt);
        updateMuzzleFlash(entity, scaledDt);
        updateCharacterFlash(entity, dt); // Use raw dt for flash timing
        updateEntityBuffs(entity, scaledDt); // Update power-up buff timers
      });
      updateRespawns(scaledDt);
      updatePopups(dt);
      updateHUD();
    }

    function updateIdle(dt) {
      world.entities.forEach((entity) => {
        updateMuzzleFlash(entity, dt);
      });
      updateCoverStates(dt);
      updatePopups(dt);
    }

	    function updateRollingBarrels(dt) {
	      if (dt <= 0) return;
	      const bounds = CONFIG.arena.bounds;

      world.barrels.forEach((barrel) => {
        if (!barrel.alive) return;
        if (!barrel.isRolling) return;

        barrel.position.addScaledVector(barrel.velocity, dt);
        barrel.rollTimer -= dt;

        const speed = Math.hypot(barrel.velocity.x, barrel.velocity.z);
        barrel.mesh.rotation.x += speed * dt * 2.5;

        const out =
          barrel.position.x < bounds.minX + barrel.radius ||
          barrel.position.x > bounds.maxX - barrel.radius ||
          barrel.position.z < bounds.minZ + barrel.radius ||
          barrel.position.z > bounds.maxZ - barrel.radius;
        if (out || barrel.rollTimer <= 0) {
          explodeBarrel(barrel);
          return;
        }

        for (const cover of world.cover) {
          if (cover.active === false) continue;
          if (circleIntersectsAABB(barrel.position, barrel.radius, cover)) {
            explodeBarrel(barrel);
            return;
          }
        }

        for (const entity of world.entities) {
          if (!entity || entity.isDead || entity.eliminated) continue;
          if (barrel.position.distanceTo(entity.position) <= barrel.radius + CONFIG.player.radius) {
            explodeBarrel(barrel);
            return;
          }
        }
	      });
	    }

		    function updateGrenades(dt) {
		      if (dt <= 0) return;
		      if (!world.grenades.length) return;
		      const bounds = CONFIG.arena.bounds;
		      const minY = 0.12;
		      const entityHitY = 1.25;
		      const barrelTopY = 1.2;
		      const gravity = CONFIG.grenade.gravity;
		      const drag = Math.max(0, 1 - CONFIG.grenade.drag * dt);
		      const wallBounce = CONFIG.grenade.wallBounce;
		      const groundBounce = CONFIG.grenade.groundBounce;

	      world.grenades = world.grenades.filter((grenade) => {
	        if (!grenade) return false;
	        grenade.fuse -= dt;
	        if (grenade.fuse <= 0) {
	          explodeGrenade(grenade);
	          return false;
	        }

	        grenade.velocity.y += gravity * dt;
	        grenade.velocity.x *= drag;
	        grenade.velocity.z *= drag;
	        grenade.position.addScaledVector(grenade.velocity, dt);

	        if (grenade.position.x < bounds.minX + grenade.radius) {
	          grenade.position.x = bounds.minX + grenade.radius;
	          grenade.velocity.x = Math.abs(grenade.velocity.x) * wallBounce;
	        } else if (grenade.position.x > bounds.maxX - grenade.radius) {
	          grenade.position.x = bounds.maxX - grenade.radius;
	          grenade.velocity.x = -Math.abs(grenade.velocity.x) * wallBounce;
	        }

	        if (grenade.position.z < bounds.minZ + grenade.radius) {
	          grenade.position.z = bounds.minZ + grenade.radius;
	          grenade.velocity.z = Math.abs(grenade.velocity.z) * wallBounce;
	        } else if (grenade.position.z > bounds.maxZ - grenade.radius) {
	          grenade.position.z = bounds.maxZ - grenade.radius;
	          grenade.velocity.z = -Math.abs(grenade.velocity.z) * wallBounce;
	        }

		        if (grenade.position.y < minY) {
		          grenade.position.y = minY;
		          if (grenade.velocity.y < -0.8) {
		            grenade.velocity.y = -grenade.velocity.y * groundBounce;
		            grenade.velocity.x *= 0.78;
		            grenade.velocity.z *= 0.78;
		          } else {
		            grenade.velocity.y = 0;
		          }
		        }

		        for (const barrel of world.barrels) {
		          if (!barrel.alive) continue;
		          if (grenade.position.y > barrelTopY + grenade.radius) continue;
		          const dist = barrel.position.distanceTo(grenade.position);
		          if (dist <= barrel.radius + grenade.radius) {
		            const nx = (grenade.position.x - barrel.position.x) / Math.max(dist, 1e-6);
		            const nz = (grenade.position.z - barrel.position.z) / Math.max(dist, 1e-6);
		            grenade.position.x = barrel.position.x + nx * (barrel.radius + grenade.radius + 0.01);
		            grenade.position.z = barrel.position.z + nz * (barrel.radius + grenade.radius + 0.01);
		            const dot = grenade.velocity.x * nx + grenade.velocity.z * nz;
		            grenade.velocity.x = (grenade.velocity.x - 2 * dot * nx) * 0.65;
		            grenade.velocity.z = (grenade.velocity.z - 2 * dot * nz) * 0.65;
		          }
		        }

		        for (const cover of world.cover) {
		          if (cover.active === false) continue;
		          const coverTopY = typeof cover.maxY === 'number' ? cover.maxY : 1.2;
		          if (grenade.position.y > coverTopY + grenade.radius + 0.08) continue;
		          if (!circleIntersectsAABB(grenade.position, grenade.radius, cover)) continue;
		          // Cheap bounce off the nearest face in XZ.
		          let clampedX = THREE.MathUtils.clamp(grenade.position.x, cover.minX, cover.maxX);
		          let clampedZ = THREE.MathUtils.clamp(grenade.position.z, cover.minZ, cover.maxZ);
	          let nx = grenade.position.x - clampedX;
	          let nz = grenade.position.z - clampedZ;
	          const lenSq = nx * nx + nz * nz;
	          if (lenSq < 1e-6) {
	            const dl = Math.abs(grenade.position.x - cover.minX);
	            const dr = Math.abs(cover.maxX - grenade.position.x);
	            const db = Math.abs(grenade.position.z - cover.minZ);
	            const df = Math.abs(cover.maxZ - grenade.position.z);
	            const min = Math.min(dl, dr, db, df);
	            if (min === dl) { nx = -1; nz = 0; clampedX = cover.minX; clampedZ = grenade.position.z; }
	            else if (min === dr) { nx = 1; nz = 0; clampedX = cover.maxX; clampedZ = grenade.position.z; }
	            else if (min === db) { nx = 0; nz = -1; clampedZ = cover.minZ; clampedX = grenade.position.x; }
	            else { nx = 0; nz = 1; clampedZ = cover.maxZ; clampedX = grenade.position.x; }
	          } else {
	            const invLen = 1 / Math.sqrt(lenSq);
	            nx *= invLen;
	            nz *= invLen;
	          }

	          grenade.position.x = clampedX + nx * (grenade.radius + 0.01);
	          grenade.position.z = clampedZ + nz * (grenade.radius + 0.01);
	          const dot = grenade.velocity.x * nx + grenade.velocity.z * nz;
	          grenade.velocity.x = (grenade.velocity.x - 2 * dot * nx) * 0.62;
		          grenade.velocity.z = (grenade.velocity.z - 2 * dot * nz) * 0.62;
		          break;
		        }

		        for (const entity of world.entities) {
		          if (!entity || entity.isDead || entity.eliminated) continue;
		          if (grenade.position.y > entityHitY + grenade.radius) continue;
		          const dx = entity.position.x - grenade.position.x;
		          const dz = entity.position.z - grenade.position.z;
		          const dist = Math.hypot(dx, dz);
		          if (dist <= CONFIG.player.radius + grenade.radius) {
		            const nx = (grenade.position.x - entity.position.x) / Math.max(dist, 1e-6);
		            const nz = (grenade.position.z - entity.position.z) / Math.max(dist, 1e-6);
		            grenade.position.x = entity.position.x + nx * (CONFIG.player.radius + grenade.radius + 0.01);
		            grenade.position.z = entity.position.z + nz * (CONFIG.player.radius + grenade.radius + 0.01);
		            const dot = grenade.velocity.x * nx + grenade.velocity.z * nz;
		            grenade.velocity.x = (grenade.velocity.x - 2 * dot * nx) * 0.55;
		            grenade.velocity.z = (grenade.velocity.z - 2 * dot * nz) * 0.55;
		            entity.velocity.x -= nx * 1.4;
		            entity.velocity.z -= nz * 1.4;
		          }
		        }

		        const speed = Math.hypot(grenade.velocity.x, grenade.velocity.z) + Math.abs(grenade.velocity.y);
	        grenade.mesh.rotation.x += dt * (3.0 + speed * 0.2);
	        grenade.mesh.rotation.z += dt * (2.4 + speed * 0.15);
	        return true;
	      });
	    }

	    function updateCoverStates(dt) {
	      world.cover.forEach((cover) => {
	        updateCoverFlash(cover, dt);
	        if (cover.active === false) return;
	        if (!cover.kickState || !cover.mesh) return;

        cover.mesh.position.addScaledVector(cover.kickState.velocity, dt);
        syncCoverColliderFromMesh(cover);
        cover.kickState.timer -= dt;

        const bounds = CONFIG.arena.bounds;
        const out =
          cover.mesh.position.x < bounds.minX ||
          cover.mesh.position.x > bounds.maxX ||
          cover.mesh.position.z < bounds.minZ ||
          cover.mesh.position.z > bounds.maxZ;
        if (out) {
          destroyCover(cover, cover.kickState.sourceTeam);
          return;
        }

        for (const other of world.cover) {
          if (other === cover) continue;
          if (other.active === false) continue;
          if (aabbOverlaps(cover, other)) {
            destroyCover(cover, cover.kickState.sourceTeam);
            return;
          }
        }

        for (const barrel of world.barrels) {
          if (!barrel.alive) continue;
          if (circleIntersectsAABB(barrel.position, barrel.radius, cover)) {
            barrel.lastDamagedByTeam = cover.kickState.sourceTeam;
            explodeBarrel(barrel);
            destroyCover(cover, cover.kickState.sourceTeam);
            return;
          }
        }

        const coverHitRadius = 0.55;
        for (const entity of world.entities) {
          if (!entity || entity.isDead || entity.eliminated) continue;
          if (circleIntersectsAABB(entity.position, coverHitRadius, cover)) {
            handleKickedCoverHit(entity, cover.kickState.sourceTeam, cover);
            return;
          }
        }

        if (cover.kickState.timer <= 0) {
          destroyCover(cover, cover.kickState.sourceTeam);
        }
      });
    }

    function handleKickedCoverHit(entity, sourceTeam, cover) {
      const attacker = getEntityByTeam(sourceTeam);
      applyDamage(entity, CONFIG.kick.coverHitDamage, sourceTeam, attacker, null, cover.mesh?.position, entity.position);
      applyStun(entity, CONFIG.kick.coverHitStun);
      destroyCover(cover, sourceTeam);
    }

    function aabbOverlaps(a, b) {
      return !(a.maxX < b.minX || a.minX > b.maxX || a.maxZ < b.minZ || a.minZ > b.maxZ);
    }

    function circleIntersectsAABB(pos, radius, box) {
      const clampedX = THREE.MathUtils.clamp(pos.x, box.minX, box.maxX);
      const clampedZ = THREE.MathUtils.clamp(pos.z, box.minZ, box.maxZ);
      const dx = pos.x - clampedX;
      const dz = pos.z - clampedZ;
      return (dx * dx + dz * dz) <= radius * radius;
    }

    function updateTimer(dt) {
      if (state.suddenDeath || state.matchEnded) return;
      state.timeLeft = Math.max(0, state.timeLeft - dt);
      if (state.timeLeft <= 0 && !state.suddenDeath && !state.matchEnded) {
        if (state.gameMode === 'deathmatch') {
          const contenders = world.entities.filter((entity) => entity && !entity.eliminated);
          if (contenders.length <= 1) {
            endMatch(contenders[0]?.team);
            return;
          }
          const maxLives = Math.max(...contenders.map(entity => entity.lives ?? 0));
          const leaders = contenders.filter(entity => (entity.lives ?? 0) === maxLives);
          if (leaders.length === 1) {
            endMatch(leaders[0].team);
          } else {
            state.suddenDeath = true;
            suddenDeathEl.classList.add('show');
          }
        } else {
          const player = getPlayer();
          const enemy = getEnemy();
          if (player && enemy && player.hp === enemy.hp) {
            state.suddenDeath = true;
            suddenDeathEl.classList.add('show');
          } else if (player && enemy) {
            endRound(player.hp > enemy.hp ? 'p1' : 'p2', true);
          }
        }
      }
    }

    function updatePlayer(player, dt) {
      if (!player || player.isDead || player.eliminated) return;
      updateWeaponSwitch(player, dt);
      updateReload(player, dt);

      if (player.stunTimer > 0) {
        player.stunTimer -= dt;
        const nextPos = player.position.clone().addScaledVector(player.velocity, dt);
        resolveCollisions(nextPos, CONFIG.player.radius);
        player.position.copy(nextPos);
        player.velocity.multiplyScalar(Math.max(0, 1 - dt * 2.2));
      } else {
        const moveDir = getMoveInput();
        applyMovement(player, moveDir, dt);
        updateAim(player, null, dt);

        const weapon = getActiveWeaponConfig(player);
        const shouldFire = weapon.auto ? input.mouse.down : input.mouse.justPressed;
        if (shouldFire) {
          attemptFire(player, getAimDirection(player), false);
        }

        // Player reloads manually; avoid auto-reload when switching.
      }

	      if (player.fireCooldown > 0) player.fireCooldown -= dt;
	      if (player.dashCooldown > 0) player.dashCooldown -= dt;
	      if (player.kickCooldown > 0) player.kickCooldown -= dt;
	      if (player.nearMissCooldown > 0) player.nearMissCooldown -= dt;
	      if (player.grenadeCooldown > 0) player.grenadeCooldown -= dt;
	      if (player.firedRecentlyTimer > 0) player.firedRecentlyTimer -= dt;
	    }

    function updateAI(enemy, dt) {
      if (!enemy || !enemy.ai || enemy.isDead || enemy.eliminated) return;
      const player = getAITarget(enemy);
      if (!player) return;

      updateWeaponSwitch(enemy, dt);
      updateReload(enemy, dt);

      if (enemy.stunTimer > 0) {
        enemy.stunTimer -= dt;
        const nextPos = enemy.position.clone().addScaledVector(enemy.velocity, dt);
        resolveCollisions(nextPos, CONFIG.player.radius);
        enemy.position.copy(nextPos);
        enemy.velocity.multiplyScalar(Math.max(0, 1 - dt * 2.2));
      }

      enemy.ai.thinkTimer -= dt;
      if (enemy.ai.thinkTimer <= 0) {
        const tuning = getAiTuning(enemy) || { aiThinkBase: 0.35, aiThinkJitter: 0.3 };
        enemy.ai.thinkTimer = tuning.aiThinkBase + (Math.random() - 0.5) * tuning.aiThinkJitter;
        decideAI(enemy, player);
      }

      // Burst cooldown management
      if (enemy.ai.burstCooldown > 0) {
        enemy.ai.burstCooldown -= dt;
      }

      if (enemy.stunTimer <= 0) {
        const desired = enemy.ai.desiredMove || new THREE.Vector3();
        applyMovement(enemy, desired, dt);
        updateAim(enemy, player.position, dt);

        const weapon = getActiveWeaponConfig(enemy);
        const weaponState = getWeaponState(enemy);

        if (weaponState.ammo <= 0 && weaponState.reloadTimer <= 0) {
          startReload(enemy);
        }

        const canFire = enemy.weapon.switchTimer <= 0 && weaponState.reloadTimer <= 0;
        if (enemy.ai.fireIntent && canFire && enemy.fireCooldown <= 0) {
          if (enemy.weapon.id === 'smg') {
            // Burst fire: AI fires 3-5 shots then pauses
            if (enemy.ai.burstCooldown <= 0) {
              attemptFire(enemy, getAimDirection(enemy, player.position), true);
              enemy.ai.burstCount += 1;
              if (enemy.ai.burstCount >= 3 + Math.floor(Math.random() * 3)) {
                enemy.ai.burstCooldown = 0.4 + Math.random() * 0.3;
                enemy.ai.burstCount = 0;
              }
            }
          } else {
            // Single, deliberate shots
            attemptFire(enemy, getAimDirection(enemy, player.position), true);
          }
        }
      }

	      if (enemy.fireCooldown > 0) enemy.fireCooldown -= dt;
	      if (enemy.dashCooldown > 0) enemy.dashCooldown -= dt;
	      if (enemy.kickCooldown > 0) enemy.kickCooldown -= dt;
	      if (enemy.nearMissCooldown > 0) enemy.nearMissCooldown -= dt;
	      if (enemy.grenadeCooldown > 0) enemy.grenadeCooldown -= dt;
	      if (enemy.firedRecentlyTimer > 0) enemy.firedRecentlyTimer -= dt;
	    }

    function getAITarget(aiEntity) {
      let best = null;
      let bestDist = Infinity;
      world.entities.forEach((entity) => {
        if (!entity || entity === aiEntity || entity.isDead || entity.eliminated) return;
        const dist = entity.position.distanceTo(aiEntity.position);
        if (dist < bestDist) {
          bestDist = dist;
          best = entity;
        }
      });
      return best;
    }

    function updateRespawns(dt) {
      if (state.gameMode !== 'deathmatch' || state.matchEnded) return;
      world.entities.forEach((entity) => {
        if (!entity || entity.eliminated || !entity.isDead) return;
        if (!entity.respawnTimer || entity.respawnTimer <= 0) return;
        entity.respawnTimer -= dt;
        if (entity.respawnTimer <= 0) {
          const spawn = chooseRespawnPoint(entity);
          resetEntity(entity, spawn);
        }
      });
    }

    function chooseRespawnPoint(entity) {
      const points = getSpawnPoints(getActiveGameMode().playerCount);
      let best = points[0] || new THREE.Vector3();
      let bestScore = -Infinity;
      points.forEach((point) => {
        let minDist = Infinity;
        world.entities.forEach((other) => {
          if (!other || other === entity || other.eliminated || other.isDead) return;
          const dist = point.distanceTo(other.position);
          if (dist < minDist) minDist = dist;
        });
        const score = minDist === Infinity ? 0 : minDist;
        if (score > bestScore) {
          bestScore = score;
          best = point;
        }
      });
      return best.clone();
    }

    function decideAI(enemy, player) {
      const toPlayer = player.position.clone().sub(enemy.position);
      const dist = Math.hypot(toPlayer.x, toPlayer.z);
      const hasLoS = hasLineOfSight(enemy.position, player.position);

      const preference = dist < 9
        ? ['shotgun', 'smg', 'pistol']
        : dist > 22
          ? ['pistol', 'smg', 'shotgun']
          : ['smg', 'pistol', 'shotgun'];
      const desiredWeapon = preference.find((id) => canUseWeapon(enemy, id)) || enemy.weapon.id;
      if (desiredWeapon !== enemy.weapon.id && enemy.weapon.switchTimer <= 0) {
        requestWeaponSwitch(enemy, desiredWeapon);
      }

      // Rare dramatic kick when close and something is kickable nearby
      if (enemy.kickCooldown <= 0 && dist < 2.2 && Math.random() < 0.06) {
        tryKick(enemy, true);
      }

      const activeWeapon = getActiveWeaponConfig(enemy);
      enemy.ai.fireIntent = hasLoS && dist < activeWeapon.range;

      if (enemy.hp <= 35) {
        enemy.ai.desiredMove = moveToCover(enemy, player, true);
        if (hasLoS && enemy.dashCooldown <= 0) tryDash(enemy, true);
        return;
      }

      if (hasLoS && dist >= 8 && dist <= 14) {
        const strafe = new THREE.Vector3(-toPlayer.z, 0, toPlayer.x).normalize();
        enemy.ai.strafeDir *= Math.random() < 0.12 ? -1 : 1;
        enemy.ai.desiredMove = strafe.multiplyScalar(enemy.ai.strafeDir);
      } else {
        enemy.ai.desiredMove = moveToCover(enemy, player, false);
      }

      if (!hasLoS && dist < 6 && enemy.dashCooldown <= 0) {
        tryDash(enemy, true);
      }
    }

    function moveToCover(enemy, player, retreat) {
      let bestNode = null;
      let bestScore = Infinity;
      world.nodes.forEach((node) => {
        const distance = node.distanceTo(player.position);
        const hasLoS = hasLineOfSight(node, player.position);
        let score = Math.abs(distance - 10);
        if (retreat && hasLoS) score += 6;
        if (!retreat && !hasLoS) score += 4;
        if (distance < 5) score += 5;
        if (score < bestScore) {
          bestScore = score;
          bestNode = node;
        }
      });

      enemy.ai.targetNode = bestNode || enemy.position;
      const dir = bestNode ? bestNode.clone().sub(enemy.position) : new THREE.Vector3();
      dir.y = 0;
      if (dir.lengthSq() > 0.1) dir.normalize();
      return dir;
    }

    function applyMovement(entity, moveDir, dt) {
      const accel = CONFIG.movement.accel;
      // Apply speed buff from power-ups
      const speedMul = entity.buffs?.speedMul || 1;
      const maxSpeed = CONFIG.movement.maxSpeed * speedMul;

      if (entity.dashTimer > 0) {
        entity.dashTimer -= dt;
        if (entity.dashTimer <= 0) {
          entity.velocity.multiplyScalar(0.2);
        }
      } else {
        if (moveDir.lengthSq() > 0) {
          const desired = moveDir.clone().normalize().multiplyScalar(maxSpeed);
          entity.velocity.x = moveToward(entity.velocity.x, desired.x, accel * dt);
          entity.velocity.z = moveToward(entity.velocity.z, desired.z, accel * dt);
        } else {
          entity.velocity.x = moveToward(entity.velocity.x, 0, accel * dt * 1.2);
          entity.velocity.z = moveToward(entity.velocity.z, 0, accel * dt * 1.2);
        }
      }

      const nextPos = entity.position.clone().addScaledVector(entity.velocity, dt);
      resolveCollisions(nextPos, CONFIG.player.radius);
      entity.position.copy(nextPos);

      const speed = Math.hypot(entity.velocity.x, entity.velocity.z);
      // Higher threshold to ensure idle plays when nearly stationary
      const weaponState = entity.weapon ? getWeaponState(entity) : null;
      const wantsReloadAnim = weaponState && weaponState.reloadTimer > 0 && entity.mixers?.actions?.reload;
      updateAnimationState(entity, wantsReloadAnim ? 'reload' : speed > 0.5 ? 'run' : 'idle');
    }

    function resolveCollisions(pos, radius) {
      world.cover.forEach((box) => {
        if (box.active === false) return;
        if (box.kickState) return;
        resolveCircleAABB(pos, radius, box);
      });
      world.barrels.forEach((barrel) => {
        if (barrel.alive && !barrel.isRolling) resolveCircleCircle(pos, radius, barrel.position, barrel.radius);
      });
      pos.x = THREE.MathUtils.clamp(pos.x, CONFIG.arena.bounds.minX + radius, CONFIG.arena.bounds.maxX - radius);
      pos.z = THREE.MathUtils.clamp(pos.z, CONFIG.arena.bounds.minZ + radius, CONFIG.arena.bounds.maxZ - radius);
    }

    function updateAim(entity, targetPos, dt) {
      const aimPoint = targetPos || getAimPoint();
      if (!aimPoint) return;
      const dir = aimPoint.clone().sub(entity.position);
      dir.y = 0;
      if (dir.lengthSq() < 0.001) return;
      dir.normalize();
      const targetYaw = Math.atan2(dir.x, dir.z);
      const maxDelta = CONFIG.movement.turnSpeed * dt;
      entity.yaw = rotateToward(entity.yaw, targetYaw, maxDelta);
      entity.group.rotation.y = entity.yaw + MODEL_YAW_OFFSET;

      if (entity.team === 'p1' && world.reticle) {
        world.reticle.position.set(aimPoint.x, 0.02, aimPoint.z);
      }
    }

    function getAimPoint() {
      raycaster.setFromCamera({ x: input.mouse.x, y: input.mouse.y }, world.camera);
      const point = new THREE.Vector3();
      const hit = raycaster.ray.intersectPlane(groundPlane, point);
      if (!hit) return null;
      point.x = THREE.MathUtils.clamp(point.x, CONFIG.arena.bounds.minX, CONFIG.arena.bounds.maxX);
      point.z = THREE.MathUtils.clamp(point.z, CONFIG.arena.bounds.minZ, CONFIG.arena.bounds.maxZ);
      return point;
    }

    function getAimDirection(entity, targetPos) {
      const aimPoint = targetPos || getAimPoint();
      const dir = aimPoint ? aimPoint.clone().sub(entity.position) : new THREE.Vector3(0, 0, 1);
      dir.y = 0;
      if (dir.lengthSq() < 0.001) dir.z = 1;
      return dir.normalize();
    }

    function getMoveInput() {
      const forward = new THREE.Vector3();
      world.camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      const dir = new THREE.Vector3();
      // Use KeyBinds system for movement keys
      if (input.keys[KeyBinds.getKey('moveUp')]) dir.add(forward);
      if (input.keys[KeyBinds.getKey('moveDown')]) dir.sub(forward);
      if (input.keys[KeyBinds.getKey('moveLeft')]) dir.sub(right);
      if (input.keys[KeyBinds.getKey('moveRight')]) dir.add(right);
      
      if (dir.lengthSq() > 0) dir.normalize();
      return dir;
    }

    function attemptFire(attacker, dir, isAI) {
      if (!attacker || attacker.isDead) return;
      if (attacker.weapon.switchTimer > 0) return;

      const weapon = getActiveWeaponConfig(attacker);
      const weaponState = getWeaponState(attacker);
      if (attacker.fireCooldown > 0 || weaponState.reloadTimer > 0) return;
      if (weaponState.ammo <= 0) return;

      const aiTuning = isAI ? (getAiTuning(attacker) || null) : null;
      const forwardBase = dir.clone().normalize();
      const rightBase = new THREE.Vector3(-forwardBase.z, 0, forwardBase.x);
      const origin = attacker.position.clone();
      origin.y = 1.05;
      origin.addScaledVector(forwardBase, 0.9);
      origin.addScaledVector(rightBase, 0.25);

      const pellets = weapon.pellets || 1;
      let didHit = false;
      let closestMissDist = Infinity;
      let closestMissEnd = null;
      let closestMissTarget = null;
      let knockApplied = false;

      for (let i = 0; i < pellets; i++) {
        const spreadBase = isAI ? weapon.spreadAI : weapon.spreadPlayer;
        const spread = spreadBase * (isAI ? (aiTuning?.aiSpreadMul ?? 1) : 1);
        const angle = (Math.random() - 0.5) * spread;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const dir2 = new THREE.Vector3(
          forwardBase.x * cos - forwardBase.z * sin,
          0,
          forwardBase.x * sin + forwardBase.z * cos
        );

        const end = origin.clone().addScaledVector(dir2, weapon.range);
        const coverHit = findCoverHit(origin, end);
        const targetHit = findClosestPlayerHit(origin, end, attacker);
        const barrelHit = findBarrelHit(origin, end);

        let hitType = null;
        let hit = null;
        let hitT = null;

        if (coverHit) {
          hitType = 'cover';
          hit = coverHit.cover;
          hitT = coverHit.t;
        }

        if (targetHit && (hitT === null || targetHit.t < hitT)) {
          hitType = 'player';
          hit = targetHit.entity;
          hitT = targetHit.t;
        }

        if (barrelHit && (hitT === null || barrelHit.t < hitT)) {
          hitType = 'barrel';
          hit = barrelHit.barrel;
          hitT = barrelHit.t;
        }

        const endT = hitT !== null ? hitT : 1;
        const shotEnd = origin.clone().lerp(end, endT);

        const isShotgun = pellets > 1;
        const drawTracer = isShotgun || pellets === 1 || i < 3;
        if (drawTracer) {
          if (isShotgun) {
            spawnTracer(origin, shotEnd, 0xfff1cc, 0.09, { additive: true, opacity: 0.92 });
          } else {
            spawnTracer(origin, shotEnd, weapon.tracer, 0.06, { additive: true, opacity: 0.8 });
          }
        }

        if (hitType === 'player') {
          didHit = true;
          const damage = weapon.damage * (isAI ? (aiTuning?.aiDamageMul ?? 1) : 1);
          applyDamage(hit, damage, attacker.team, attacker, weapon, origin, shotEnd);
          if (!knockApplied) {
            applyKnockback(hit, attacker.position, weapon.knockback);
            knockApplied = true;
          }
        } else if (hitType === 'barrel') {
          didHit = true;
          applyBarrelDamage(hit, weapon.damage, attacker.team);
        } else if (hitType === 'cover') {
          didHit = true;
          applyCoverDamage(hit, weapon.damage, attacker.team);
        } else {
          const miss = findClosestMiss(origin, shotEnd, attacker);
          if (miss && miss.dist < closestMissDist) {
            closestMissDist = miss.dist;
            closestMissEnd = shotEnd.clone();
            closestMissTarget = miss.entity;
          }
        }
      }

      triggerMuzzle(attacker, forwardBase, weapon);
      triggerRecoil();
      triggerShootAnimation(attacker);
      attacker.firedRecentlyTimer = 0.25;

      // Play weapon-specific sound
      if (attacker.isPlayer || !isAI) {
        const weaponId = attacker.weapon.id;
        if (weaponId === 'pistol') AudioManager.playPistol();
        else if (weaponId === 'smg') AudioManager.playSMG();
        else if (weaponId === 'shotgun') AudioManager.playShotgun();
        else if (weaponId === 'sniper') AudioManager.playSniper();
        else if (weaponId === 'rocket') AudioManager.playRocket();
      }

      // Track match stats
      if (attacker.matchStats) {
        attacker.matchStats.shotsFired++;
        if (didHit) attacker.matchStats.shotsHit++;
      }

      const fireRateBase = isAI ? weapon.fireRateAI : weapon.fireRate;
      const fireRate = fireRateBase * (isAI ? (aiTuning?.aiFireRateMul ?? 1) : 1);
      attacker.fireCooldown = 1 / fireRate;
      weaponState.ammo -= 1;

      if (!didHit && closestMissEnd && closestMissTarget) {
        checkNearMiss(origin, closestMissEnd, closestMissTarget);
      }
    }

    function startReload(entity) {
      if (!entity || entity.isDead) return;
      if (entity.stunTimer > 0) return;
      if (entity.weapon.switchTimer > 0) return;
      const weapon = getActiveWeaponConfig(entity);
      const state = getWeaponState(entity);
      if (state.reloadTimer > 0) return;
      if (state.ammo >= weapon.magSize) return;
      if (state.reserve <= 0) return;
      state.reloadTimer = weapon.reload;
      updateAnimationState(entity, 'reload');
      if (entity.isPlayer) AudioManager.playReload();
    }

    function updateReload(entity, dt) {
      if (!entity || entity.isDead) return;
      const weapon = getActiveWeaponConfig(entity);
      const state = getWeaponState(entity);
      if (state.reloadTimer <= 0) return;
      state.reloadTimer -= dt;
      if (state.reloadTimer > 0) return;

      if (weapon.reloadType === 'shell') {
        if (state.reserve <= 0) {
          state.reloadTimer = 0;
          return;
        }
        state.ammo = Math.min(weapon.magSize, state.ammo + 1);
        state.reserve = Math.max(0, state.reserve - 1);
        if (state.ammo < weapon.magSize && state.reserve > 0) {
          state.reloadTimer = weapon.reload;
        } else {
          state.reloadTimer = 0;
        }
      } else {
        const needed = weapon.magSize - state.ammo;
        const take = Math.min(needed, state.reserve);
        state.ammo += take;
        state.reserve = Math.max(0, state.reserve - take);
        state.reloadTimer = 0;
      }
    }

    function applyDamage(target, amount, sourceTeam, attacker = null, weapon = null, shotStart = null, shotEnd = null) {
      if (target.isDead) return;
      
      // Apply attacker's damage buff
      let finalDamage = amount;
      if (attacker && attacker.buffs?.damageMul) {
        finalDamage *= attacker.buffs.damageMul;
      }
      
      // Handle shield absorption
      if (target.shield && target.shield > 0) {
        const shieldAbsorb = Math.min(target.shield, finalDamage);
        target.shield -= shieldAbsorb;
        finalDamage -= shieldAbsorb;
        if (shieldAbsorb > 0) {
          // Show shield damage separately
          const shieldPos = target.position.clone();
          shieldPos.y = 2.4;
          spawnPopup('SHIELD', shieldPos, 'close', 0.4);
        }
      }
      
      if (state.suddenDeath) {
        target.hp = 0;
      } else {
        target.hp = Math.max(0, target.hp - finalDamage);
      }
      fx.hitFlashTimer = 0.06;
      fx.hitstopTimer = 0.06;
      
      // Play hit sound
      AudioManager.playHit();

      // Spawn hit effect at target position
      spawnHitEffect(target.position, target.team);
      // Flash the character red briefly
      flashCharacter(target, 0.15);
      
      // Show damage number if enabled
      if (GameSettings.data.showDamageNumbers && finalDamage > 0) {
        const dmgPos = target.position.clone();
        dmgPos.y = 2.0;
        const isCrit = finalDamage >= 40;
        spawnDamageNumber(Math.round(finalDamage), dmgPos, isCrit);
      }
      
      // Track match stats
      if (target.matchStats) {
        target.matchStats.damageTaken += finalDamage;
      }
      if (attacker && attacker.matchStats) {
        attacker.matchStats.damageDealt += finalDamage;
      }

      if (target.hp <= 0) {
        handleEntityDeath(target, sourceTeam, attacker, shotStart, shotEnd);
      }
    }

    function handleEntityDeath(target, sourceTeam, attacker, shotStart, shotEnd) {
      target.isDead = true;
      playDeathAnimation(target);
      // Bigger hit effect on death
      spawnHitEffect(target.position, target.team, true);
      fx.shakeTime = 0.3;
      fx.shakeIntensity = 0.55;
      
      // Play death sound
      AudioManager.playDeath();
      
      // Track match stats
      if (target.matchStats) {
        target.matchStats.deaths++;
      }
      if (attacker && attacker.matchStats) {
        attacker.matchStats.kills++;
      }
      
      // Track persistent stats for player
      if (target.isPlayer) {
        PlayerStats.addDeath();
      }
      if (attacker && attacker.isPlayer && attacker.weapon) {
        PlayerStats.addKill(attacker.weapon.id);
      }
      
      if (attacker) {
        state.lastKill = {
          shooterTeam: attacker.team,
          victimTeam: target.team,
          shooterPos: attacker.position.clone(),
          victimPos: target.position.clone(),
          shotStart: shotStart ? shotStart.clone() : null,
          shotEnd: shotEnd ? shotEnd.clone() : null,
          weaponId: attacker.weapon.id
        };
      } else {
        state.lastKill = null;
      }

      if (state.gameMode === 'deathmatch') {
        handleDeathmatchDeath(target);
      } else {
        endRound(sourceTeam, false);
      }
    }

    function handleDeathmatchDeath(target) {
      target.lives = Math.max(0, (target.lives ?? 0) - 1);
      const popupPos = target.position.clone();
      popupPos.y = 2.2;

      if (target.lives <= 0) {
        target.eliminated = true;
        spawnPopup('ELIMINATED', popupPos, 'close', 0.9);
      } else {
        target.respawnTimer = 1.2;
        spawnPopup(`RESPAWN ${target.lives}`, popupPos, 'close', 0.7);
      }

      const survivors = world.entities.filter((entity) => entity && !entity.eliminated);
      if (survivors.length <= 1) {
        const winnerTeam = survivors[0]?.team;
        if (state.lastKill && winnerTeam) {
          triggerKillCam(winnerTeam);
        } else {
          endMatch(winnerTeam);
        }
      }
    }

    function applyKnockback(target, attackerPos, strength) {
      if (!target || target.isDead) return;
      if (!strength || strength <= 0) return;
      const dir = target.position.clone().sub(attackerPos);
      dir.y = 0;
      if (dir.lengthSq() < 0.001) return;
      dir.normalize();
      target.velocity.addScaledVector(dir, strength * 3.0);
    }

    function applyStun(entity, duration) {
      if (!entity || entity.isDead) return;
      if (!duration || duration <= 0) return;
      const wasStunned = entity.stunTimer > 0;
      entity.stunTimer = Math.max(entity.stunTimer, duration);
      if (!wasStunned) triggerStunReaction(entity);
    }

    function triggerStunReaction(entity) {
      if (!entity || entity.isDead) return;
      if (entity.mixers?.actions?.hit) {
        updateAnimationState(entity, 'hit');
      } else {
        // Fallback: tilt the whole character group to sell the knockdown.
        entity.stunTilt = Math.min(entity.stunTilt, -0.15);
      }
    }

    function updateStunVisual(entity, dt) {
      if (!entity || !entity.group) return;
      const hasHitClip = Boolean(entity.mixers?.actions?.hit);
      if (hasHitClip) {
        entity.group.rotation.x = moveToward(entity.group.rotation.x, 0, dt * 8);
        return;
      }
      const target = entity.stunTimer > 0 ? -0.6 : 0;
      entity.stunTilt = moveToward(entity.stunTilt || 0, target, dt * 5.5);
      entity.group.rotation.x = entity.stunTilt;
    }

    function applyCoverDamage(cover, amount, sourceTeam) {
      if (!cover || cover.active === false) return;
      if (!cover.destructible) return;
      cover.hp = Math.max(0, cover.hp - amount);
      flashCover(cover, CONFIG.cover.flashTime);
      if (cover.hp <= 0) {
        destroyCover(cover, sourceTeam);
      }
    }

    function destroyCover(cover, sourceTeam) {
      if (!cover || cover.active === false) return;
      cover.active = false;
      if (cover.mesh) cover.mesh.visible = false;
      spawnCoverDebris(cover, sourceTeam);
      maybeSpawnCoverPickup(cover);
      buildCoverNodes();
    }

    function maybeSpawnCoverPickup(cover) {
      if (!cover || !cover.destructible) return;
      if (Math.random() > CONFIG.pickups.crateDropChance) return;
      const weaponId = rollWeaponDrop();
      if (!weaponId) return;
      const pos = cover.mesh
        ? cover.mesh.position.clone()
        : new THREE.Vector3((cover.minX + cover.maxX) / 2, 0, (cover.minZ + cover.maxZ) / 2);
      spawnWeaponPickup(pos, weaponId);
    }

    function rollWeaponDrop() {
      const entries = Object.entries(CONFIG.weapons);
      const total = entries.reduce((sum, [, cfg]) => sum + (cfg.dropChance || 0), 0);
      if (total <= 0) return null;
      let roll = Math.random() * total;
      for (const [weaponId, cfg] of entries) {
        roll -= cfg.dropChance || 0;
        if (roll <= 0) return weaponId;
      }
      return entries[0]?.[0] || null;
    }

    function flashCover(cover, duration) {
      if (!cover.mesh) return;
      cover.flashTimer = duration;
      if (!cover.originalMaterials) {
        cover.originalMaterials = [];
        cover.mesh.traverse((child) => {
          if (child.isMesh && child.material) {
            cover.originalMaterials.push({ mesh: child, material: child.material });
          }
        });
      }
      const flashMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      cover.mesh.traverse((child) => {
        if (child.isMesh) child.material = flashMat;
      });
    }

    function updateCoverFlash(cover, dt) {
      if (!cover.flashTimer || cover.flashTimer <= 0) return;
      cover.flashTimer -= dt;
      if (cover.flashTimer <= 0 && cover.originalMaterials) {
        cover.originalMaterials.forEach(({ mesh, material }) => {
          mesh.material = material;
        });
      }
    }

    function spawnCoverDebris(cover, sourceTeam) {
      const color = getTeamColor(sourceTeam);
      const center = cover.mesh ? cover.mesh.position.clone() : new THREE.Vector3(
        (cover.minX + cover.maxX) / 2,
        0,
        (cover.minZ + cover.maxZ) / 2
      );
      const pieces = 8;
      for (let i = 0; i < pieces; i++) {
        const size = 0.12 + Math.random() * 0.16;
        const geometry = new THREE.BoxGeometry(size, size, size);
        const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.85 });
        const piece = new THREE.Mesh(geometry, material);
        piece.position.copy(center);
        piece.position.y = 0.6 + Math.random() * 0.8;
        const angle = Math.random() * Math.PI * 2;
        const speed = 4 + Math.random() * 4;
        piece.userData = {
          velocity: new THREE.Vector3(Math.cos(angle) * speed, 4 + Math.random() * 4, Math.sin(angle) * speed),
          life: 1.0,
          maxLife: 1.0
        };
        world.scene.add(piece);
        world.fxParticles.push(piece);
      }
    }

	    function spawnWeaponPickup(position, weaponId) {
	      const weapon = CONFIG.weapons[weaponId];
	      if (!weapon) return;
	      const { mesh, activeVisual } = createPickupMesh(weaponId);
	      mesh.position.copy(position);
	      const pickup = {
	        weaponId,
	        mesh,
	        visuals: (() => {
	          const visuals = { gltf: null, placeholder: null };
	          visuals[activeVisual] = mesh;
	          return visuals;
	        })(),
	        activeVisual,
	        basePos: position.clone(),
	        bobTimer: Math.random() * Math.PI * 2
	      };
	      world.scene.add(mesh);
	      world.pickups.push(pickup);
	    }

	    function createPickupMesh(weaponId, { ignorePlaceholders = false } = {}) {
	      const group = new THREE.Group();
	      const manifest = assets.manifest.assets.toonshooter;
	      const gunPath = weaponId === 'pistol'
	        ? manifest.guns.Pistol
	        : weaponId === 'smg'
	          ? manifest.guns.SMG
	          : manifest.guns.Shotgun;
	      const clone = gunPath ? cloneAsset(gunPath, { ignorePlaceholders }) : null;
	      const activeVisual = clone ? 'gltf' : 'placeholder';
	      if (clone) {
	        const gun = normalizeToHeight(clone.root, 0.55);
	        gun.rotation.y = Math.PI / 2;
	        gun.position.y = 0.4;
	        group.add(gun);
	      } else {
	        const fallback = new THREE.Mesh(
	          new THREE.BoxGeometry(0.6, 0.2, 0.8),
	          new THREE.MeshStandardMaterial({ color: COLORS.steel, roughness: 0.5, metalness: 0.2 })
	        );
	        fallback.position.y = 0.4;
	        markPlaceholder(fallback);
	        group.add(fallback);
	      }

      const ring = new THREE.Mesh(
        new THREE.CylinderGeometry(0.55, 0.55, 0.08, 18),
        new THREE.MeshStandardMaterial({
          color: weaponId === 'pistol' ? 0xffd24d : weaponId === 'smg' ? 0x7ac8ff : 0xff8a3d,
          roughness: 0.4,
          metalness: 0.1,
          emissive: 0x111111
        })
      );
	      ring.position.y = 0.04;
	      group.add(ring);
	      return { mesh: group, activeVisual };
	    }

    function updatePickups(dt) {
      if (world.pickups.length === 0) return;
      const bobHeight = CONFIG.pickups.floatHeight;
      const bobAmt = CONFIG.pickups.bobAmount;
      const bobSpeed = CONFIG.pickups.bobSpeed;
      const spin = CONFIG.pickups.rotateSpeed;
      const radius = CONFIG.pickups.collectRadius;

      world.pickups = world.pickups.filter((pickup) => {
        pickup.bobTimer += dt * bobSpeed;
        pickup.mesh.position.y = pickup.basePos.y + bobHeight + Math.sin(pickup.bobTimer) * bobAmt;
        pickup.mesh.rotation.y += spin * dt;

        for (const entity of world.entities) {
          if (!entity || entity.isDead) continue;
          if (entity.position.distanceTo(pickup.mesh.position) <= radius) {
            collectPickup(entity, pickup);
            world.scene.remove(pickup.mesh);
            return false;
          }
        }
        return true;
      });
    }

    function collectPickup(entity, pickup) {
      const weaponId = pickup.weaponId;
      const weapon = CONFIG.weapons[weaponId];
      const state = getWeaponState(entity, weaponId);
      if (!weapon || !state) return;
      const wasLocked = !state.unlocked;
      state.unlocked = true;
      if (wasLocked) {
        state.ammo = weapon.magSize;
      }
      const addAmount = getPickupAmmoAmount(weaponId);
      state.reserve = Math.min(weapon.reserveMax, state.reserve + addAmount);
      if (entity.weapon.id === weaponId && state.ammo < weapon.magSize && state.reloadTimer <= 0) {
        startReload(entity);
      }
      if (entity.isPlayer) {
        const popupPos = entity.position.clone();
        popupPos.y = 2.2;
        spawnPopup(`${weapon.name.toUpperCase()} +${addAmount}`, popupPos, 'close', 0.7);
      }
    }

    function getPickupAmmoAmount(weaponId) {
      const weapon = CONFIG.weapons[weaponId];
      if (!weapon) return 0;
      return Math.ceil(weapon.reserveMax * 0.4);
    }

    function clearPickups() {
      world.pickups.forEach((pickup) => {
        world.scene.remove(pickup.mesh);
      });
      world.pickups = [];
      world.fallingCrates.forEach((crate) => {
        world.scene.remove(crate.mesh);
      });
      world.fallingCrates = [];
      // Also clear power-ups
      if (world.powerups) {
        world.powerups.forEach((p) => world.scene.remove(p.mesh));
        world.powerups = [];
      }
    }

    // ==================== POWER-UP SYSTEM ====================
    function initPowerups() {
      if (!world.powerups) world.powerups = [];
      state.powerupTimer = CONFIG.powerups.spawnInterval + (Math.random() - 0.5) * CONFIG.powerups.spawnVariance;
    }

    function updatePowerups(dt) {
      if (!world.powerups) world.powerups = [];
      
      // Spawn timer
      if (!state.powerupTimer) state.powerupTimer = CONFIG.powerups.spawnInterval;
      state.powerupTimer -= dt;
      if (state.powerupTimer <= 0 && world.powerups.length < 3) {
        spawnRandomPowerup();
        state.powerupTimer = CONFIG.powerups.spawnInterval + (Math.random() - 0.5) * CONFIG.powerups.spawnVariance;
      }
      
      // Update and collect
      const bobHeight = CONFIG.powerups.floatHeight;
      const bobAmt = CONFIG.powerups.bobAmount;
      const bobSpeed = CONFIG.powerups.bobSpeed;
      const radius = CONFIG.powerups.collectRadius;
      
      world.powerups = world.powerups.filter((powerup) => {
        powerup.bobTimer = (powerup.bobTimer || 0) + dt * bobSpeed;
        powerup.mesh.position.y = powerup.basePos.y + bobHeight + Math.sin(powerup.bobTimer) * bobAmt;
        powerup.mesh.rotation.y += 2 * dt;
        
        for (const entity of world.entities) {
          if (!entity || entity.isDead || entity.eliminated) continue;
          if (entity.position.distanceTo(powerup.mesh.position) <= radius) {
            collectPowerup(entity, powerup);
            world.scene.remove(powerup.mesh);
            return false;
          }
        }
        return true;
      });
    }

    function spawnRandomPowerup() {
      const types = Object.keys(CONFIG.powerups.types);
      const typeId = types[Math.floor(Math.random() * types.length)];
      const bounds = CONFIG.arena.bounds;
      const x = bounds.minX + 2 + Math.random() * (bounds.maxX - bounds.minX - 4);
      const z = bounds.minZ + 2 + Math.random() * (bounds.maxZ - bounds.minZ - 4);
      spawnPowerup(new THREE.Vector3(x, 0, z), typeId);
    }

    function spawnPowerup(position, typeId) {
      const cfg = CONFIG.powerups.types[typeId];
      if (!cfg) return;
      
      const group = new THREE.Group();
      
      // Glowing outer ring
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.4, 0.08, 8, 24),
        new THREE.MeshStandardMaterial({
          color: cfg.color,
          emissive: cfg.color,
          emissiveIntensity: 0.5,
          roughness: 0.3,
          metalness: 0.7
        })
      );
      ring.rotation.x = Math.PI / 2;
      group.add(ring);
      
      // Inner sphere
      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 16, 16),
        new THREE.MeshStandardMaterial({
          color: cfg.color,
          emissive: cfg.color,
          emissiveIntensity: 0.3,
          roughness: 0.4,
          metalness: 0.5
        })
      );
      group.add(sphere);
      
      group.position.copy(position);
      group.position.y = CONFIG.powerups.floatHeight;
      world.scene.add(group);
      
      if (!world.powerups) world.powerups = [];
      world.powerups.push({
        typeId,
        mesh: group,
        basePos: position.clone(),
        bobTimer: Math.random() * Math.PI * 2
      });
    }

    function collectPowerup(entity, powerup) {
      const cfg = CONFIG.powerups.types[powerup.typeId];
      if (!cfg) return;
      
      AudioManager.playPickup();
      
      const effect = cfg.effect;
      
      // Apply effect
      if (effect.hp) {
        entity.hp = Math.min(100, entity.hp + effect.hp);
      }
      if (effect.shield) {
        entity.shield = Math.min(50, (entity.shield || 0) + effect.shield);
      }
      if (effect.speedMul && cfg.duration > 0) {
        entity.buffs.speedMul = effect.speedMul;
        entity.buffs.speedTimer = cfg.duration;
      }
      if (effect.damageMul && cfg.duration > 0) {
        entity.buffs.damageMul = effect.damageMul;
        entity.buffs.damageTimer = cfg.duration;
      }
      
      // Track stats
      if (entity.matchStats) {
        entity.matchStats.powerupsCollected++;
      }
      
      // Show popup
      if (entity.isPlayer) {
        const popupPos = entity.position.clone();
        popupPos.y = 2.2;
        spawnPopup(cfg.name.toUpperCase(), popupPos, 'close', 0.8);
      }
    }

    function updateEntityBuffs(entity, dt) {
      if (!entity || !entity.buffs) return;
      
      // Speed buff timer
      if (entity.buffs.speedTimer > 0) {
        entity.buffs.speedTimer -= dt;
        if (entity.buffs.speedTimer <= 0) {
          entity.buffs.speedMul = 1;
        }
      }
      
      // Damage buff timer
      if (entity.buffs.damageTimer > 0) {
        entity.buffs.damageTimer -= dt;
        if (entity.buffs.damageTimer <= 0) {
          entity.buffs.damageMul = 1;
        }
      }
    }

    function clearGrenades() {
      world.grenades.forEach((grenade) => {
        if (grenade && grenade.mesh) world.scene.remove(grenade.mesh);
      });
      world.grenades = [];
    }

    function updateSkyDrops(dt) {
      world.skyDropTimer -= dt;
      if (world.skyDropTimer > 0) return;
      const bounds = CONFIG.arena.bounds;
      const margin = 2.5;
      const x = THREE.MathUtils.randFloat(bounds.minX + margin, bounds.maxX - margin);
      const z = THREE.MathUtils.randFloat(bounds.minZ + margin, bounds.maxZ - margin);
      spawnFallingCrate(new THREE.Vector3(x, 0, z));
      world.skyDropTimer = CONFIG.pickups.skyDropInterval
        + (Math.random() * 2 - 1) * CONFIG.pickups.skyDropVariance;
    }

	    function spawnFallingCrate(position) {
	      const { mesh, activeVisual } = createCrateMesh();
	      mesh.position.set(position.x, 12, position.z);
	      const weaponId = rollWeaponDrop();
	      const entry = {
	        mesh,
	        visuals: (() => {
	          const visuals = { gltf: null, placeholder: null };
	          visuals[activeVisual] = mesh;
	          return visuals;
	        })(),
	        activeVisual,
	        weaponId,
	        velocity: new THREE.Vector3(0, -4, 0)
	      };
	      world.scene.add(mesh);
	      world.fallingCrates.push(entry);
	    }

		    function createCrateMesh({ ignorePlaceholders = false } = {}) {
		      const manifest = assets.manifest.assets.toonshooter;
		      const cratePath = manifest.environment.Crate;
		      const clone = cratePath ? cloneAsset(cratePath, { ignorePlaceholders }) : null;
	      const activeVisual = clone ? 'gltf' : 'placeholder';
	      if (clone) {
	        const root = normalizeToHeight(clone.root, null);
	        root.traverse?.((child) => {
	          if (child.isMesh) {
	            child.castShadow = true;
	            child.receiveShadow = true;
	          }
	        });
	        return { mesh: root, activeVisual };
	      }
	      const root = markPlaceholder(new THREE.Mesh(
	        new THREE.BoxGeometry(1.2, 1.2, 1.2),
	        new THREE.MeshStandardMaterial({ color: COLORS.dustDark, roughness: 0.8, metalness: 0.05 })
	      ));
		      return { mesh: root, activeVisual };
		    }

		    function createGrenadeMesh({ ignorePlaceholders = false } = {}) {
		      const group = new THREE.Group();
		      const manifest = assets.manifest.assets.toonshooter;
		      const grenadePath = manifest.guns.Grenade;
		      const clone = grenadePath ? cloneAsset(grenadePath, { ignorePlaceholders }) : null;
		      const activeVisual = clone ? 'gltf' : 'placeholder';

		      if (clone) {
		        const grenade = normalizeToHeight(clone.root, 0.32);
		        grenade.rotation.y = Math.PI / 2;
		        grenade.position.y = 0.12;
		        grenade.traverse?.((child) => {
		          if (child.isMesh) {
		            child.castShadow = true;
		            child.receiveShadow = true;
		          }
		        });
		        group.add(grenade);
		      } else {
		        const fallback = markPlaceholder(new THREE.Mesh(
		          new THREE.IcosahedronGeometry(0.14, 0),
		          new THREE.MeshStandardMaterial({
		            color: COLORS.warning,
		            roughness: 0.35,
		            metalness: 0.2,
		            emissive: 0x221100
		          })
		        ));
		        fallback.castShadow = true;
		        fallback.receiveShadow = true;
		        group.add(fallback);
		      }

		      return { mesh: group, activeVisual };
		    }

	    function updateFallingCrates(dt) {
	      if (world.fallingCrates.length === 0) return;
	      const gravity = -18;
	      world.fallingCrates = world.fallingCrates.filter((crate) => {
        crate.velocity.y += gravity * dt;
        crate.mesh.position.addScaledVector(crate.velocity, dt);
        if (crate.mesh.position.y <= 0.6) {
          crate.mesh.position.y = 0.6;
          fx.shakeTime = 0.25;
          fx.shakeIntensity = 0.45;
          if (crate.weaponId) {
            spawnWeaponPickup(crate.mesh.position.clone(), crate.weaponId);
          }
          world.scene.remove(crate.mesh);
          return false;
        }
        return true;
      });
    }

    function spawnHitEffect(position, team, isDeath = false) {
      const color = getTeamColor(team);
      const particleCount = isDeath ? 12 : 5;
      const speed = isDeath ? 6 : 3;

      for (let i = 0; i < particleCount; i++) {
        // Create small blood/impact particle
        const size = 0.08 + Math.random() * 0.12;
        const geometry = new THREE.SphereGeometry(size, 6, 6);
        const material = new THREE.MeshBasicMaterial({
          color: isDeath ? 0xcc2222 : color,
          transparent: true,
          opacity: 0.9
        });
        const particle = new THREE.Mesh(geometry, material);

        // Start at hit position
        particle.position.copy(position);
        particle.position.y = 0.8 + Math.random() * 0.6;

        // Random velocity outward
        const angle = Math.random() * Math.PI * 2;
        const vSpeed = speed * (0.5 + Math.random() * 0.5);
        particle.userData = {
          velocity: new THREE.Vector3(
            Math.cos(angle) * vSpeed,
            2 + Math.random() * 3,
            Math.sin(angle) * vSpeed
          ),
          life: 0.4 + Math.random() * 0.3,
          maxLife: 0.4 + Math.random() * 0.3
        };

        world.scene.add(particle);
        world.fxParticles.push(particle);
      }
    }

    function spawnExplosionSparks(position, count = 16, color = 0xffc44d) {
      for (let i = 0; i < count; i++) {
        const size = 0.06 + Math.random() * 0.09;
        const geometry = new THREE.SphereGeometry(size, 6, 6);
        const material = new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity: 0.95
        });
        const particle = new THREE.Mesh(geometry, material);

        particle.position.copy(position);
        particle.position.y = 0.25 + Math.random() * 0.6;

        const angle = Math.random() * Math.PI * 2;
        const horiz = 7 + Math.random() * 7;
        const up = 7 + Math.random() * 10;
        particle.userData = {
          velocity: new THREE.Vector3(Math.cos(angle) * horiz, up, Math.sin(angle) * horiz),
          life: 0.28 + Math.random() * 0.18,
          maxLife: 0.28 + Math.random() * 0.18
        };

        world.scene.add(particle);
        world.fxParticles.push(particle);
      }
    }

    function flashCharacter(entity, duration) {
      if (!entity.root) return;
      entity.flashTimer = duration;
      // Store original materials if not already stored
      if (!entity.originalMaterials) {
        entity.originalMaterials = [];
        entity.root.traverse((child) => {
          if (child.isMesh && child.material) {
            entity.originalMaterials.push({ mesh: child, material: child.material });
          }
        });
      }
      // Apply red flash material
      const flashMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
      entity.root.traverse((child) => {
        if (child.isMesh) {
          child.material = flashMat;
        }
      });
    }

    function updateCharacterFlash(entity, dt) {
      if (!entity.flashTimer || entity.flashTimer <= 0) return;
      entity.flashTimer -= dt;
      if (entity.flashTimer <= 0 && entity.originalMaterials) {
        // Restore original materials
        entity.originalMaterials.forEach(({ mesh, material }) => {
          mesh.material = material;
        });
      }
    }

    function playDeathAnimation(entity) {
      const mixerEntry = entity.mixers;
      if (!mixerEntry) return;
      // Stop all other animations and play death
      Object.values(mixerEntry.actions).forEach(action => {
        if (action && action !== mixerEntry.actions.death) {
          action.fadeOut(0.1);
        }
      });
      if (mixerEntry.actions.death) {
        mixerEntry.actions.death.reset();
        mixerEntry.actions.death.fadeIn(0.1);
        mixerEntry.actions.death.play();
        mixerEntry.current = 'death';
      }
    }

    function applyBarrelDamage(barrel, amount, sourceTeam = null) {
      if (!barrel.alive) return;
      if (sourceTeam) barrel.lastDamagedByTeam = sourceTeam;
      barrel.hp -= amount;
      if (barrel.hp <= 0) {
        explodeBarrel(barrel);
      }
    }

    function explodeBarrel(barrel) {
      barrel.alive = false;
      barrel.mesh.visible = false;
      barrel.isRolling = false;
      barrel.rollTimer = 0;
      spawnExplosion(barrel.position);
      fx.shakeTime = 0.22;
      fx.shakeIntensity = 0.35;
      
      // Play explosion sound
      AudioManager.playExplosion();

      const sourceTeam = barrel.lastDamagedByTeam || null;
      const attacker = sourceTeam ? getEntityByTeam(sourceTeam) : null;

      world.entities.forEach((entity) => {
        const dist = barrel.position.distanceTo(entity.position);
        if (dist > CONFIG.barrel.explosionRadius) return;
        const falloff = 1 - dist / CONFIG.barrel.explosionRadius;
        const dmg = CONFIG.barrel.maxDamage * falloff;
        if (dmg > 0) {
          const creditTeam = sourceTeam || getFallbackOpponentTeam(entity.team);
          applyDamage(entity, dmg, creditTeam, attacker, null, barrel.position, entity.position);
        }
        const knockDir = entity.position.clone().sub(barrel.position).normalize();
        entity.velocity.addScaledVector(knockDir, 10 * falloff);
        applyStun(entity, 0.55 * falloff);
      });

      const spilledPath = assets.manifest.assets.toonshooter.environment.ExplodingBarrel_Spilled;
      const spilledClone = cloneAsset(spilledPath);
	      if (spilledClone) {
	        const root = normalizeToHeight(spilledClone.root, null);
	        root.position.copy(barrel.position);
	        world.scene.add(root);
        // Track this mesh so we can remove it on round reset
        world.spilledBarrels.push(root);
        barrel.spilledMesh = root; // Also link it to the barrel
	      }
	    }

	    function explodeGrenade(grenade) {
	      if (!grenade) return;
	      const pos = grenade.position ? grenade.position.clone() : grenade.mesh?.position?.clone?.();
	      if (!pos) return;

	      spawnExplosion(pos);
	      spawnExplosionSparks(pos, 18, 0xffb13d);
	      
	      // Play explosion sound
	      AudioManager.playExplosion();

	      const blast = createSprite(0xffb13d, 2.6);
	      blast.material.blending = THREE.AdditiveBlending;
	      blast.material.depthWrite = false;
	      blast.position.copy(pos).add(new THREE.Vector3(0, 0.9, 0));
	      blast.userData.life = 0.16;
	      world.scene.add(blast);
	      world.fxSprites.push(blast);

	      const smoke2 = createSprite(0x3a3a3a, 3.4);
	      smoke2.position.copy(pos).add(new THREE.Vector3(0, 1.2, 0));
	      smoke2.userData.life = 0.52;
	      world.scene.add(smoke2);
	      world.fxSprites.push(smoke2);

	      fx.hitstopTimer = Math.max(fx.hitstopTimer, 0.085);
	      setTimeScale(0.62, 0.16);
	      fx.fovPulse = Math.max(fx.fovPulse, 1.25);
	      fx.shakeTime = Math.max(fx.shakeTime, 0.42);
	      fx.shakeIntensity = Math.max(fx.shakeIntensity, 0.85);

	      const sourceTeam = grenade.sourceTeam || null;
	      const attacker = sourceTeam ? getEntityByTeam(sourceTeam) : null;
	      const radius = CONFIG.grenade.explosionRadius;
	      const maxDamage = CONFIG.grenade.maxDamage;
	      const maxKnock = CONFIG.grenade.knockback;
	      const maxStun = CONFIG.grenade.stun;

      world.entities.forEach((entity) => {
        if (!entity || entity.isDead || entity.eliminated) return;
	        const dx = entity.position.x - pos.x;
	        const dz = entity.position.z - pos.z;
	        const dist = Math.hypot(dx, dz);
	        if (dist > radius) return;

	        let falloff = 1 - dist / radius;
	        if (!hasLineOfSight(pos, entity.position)) falloff *= 0.7;
	        if (falloff <= 0) return;

	        const creditTeam = sourceTeam && entity.team !== sourceTeam ? sourceTeam : getFallbackOpponentTeam(entity.team);
	        const creditedAttacker = sourceTeam && entity.team !== sourceTeam ? attacker : null;

	        const dmg = maxDamage * falloff;
	        if (dmg > 0.5) {
	          applyDamage(entity, dmg, creditTeam, creditedAttacker, null, pos, entity.position);
	        }

        const dir = new THREE.Vector3(dx, 0, dz);
        if (dir.lengthSq() > 1e-6) dir.normalize();
        const oomph = (0.65 + 0.6 * falloff);
        entity.velocity.addScaledVector(dir, maxKnock * falloff * oomph);
        applyStun(entity, maxStun * falloff);
      });

	      world.barrels.forEach((barrel) => {
	        if (!barrel.alive) return;
	        const dist = barrel.position.distanceTo(pos);
	        if (dist > radius) return;
	        const falloff = 1 - dist / radius;
	        if (falloff <= 0) return;
	        applyBarrelDamage(barrel, CONFIG.barrel.hp * 1.2 * falloff, sourceTeam);
	      });

	      world.cover.forEach((cover) => {
	        if (cover.active === false) return;
	        if (!cover.destructible) return;
	        const center = cover.mesh?.position || null;
	        if (!center) return;
	        const dist = center.distanceTo(pos);
	        if (dist > radius) return;
	        const falloff = 1 - dist / radius;
	        if (falloff <= 0) return;
	        applyCoverDamage(cover, maxDamage * 0.45 * falloff, sourceTeam || null);
	      });

	      if (grenade.mesh) world.scene.remove(grenade.mesh);
	      grenade.mesh = null;
	    }

	    function checkNearMiss(start, end, target) {
	      if (target.nearMissCooldown > 0) return;
	      const dist = distancePointToSegmentXZ(target.position, start, end);
	      if (dist <= CONFIG.nearMissDrama.distance) {
        fx.nearMissTimer = 0.22;
        fx.dramaticTimer = CONFIG.nearMissDrama.duration;
        fx.dramaticTeam = target.team;
        setTimeScale(CONFIG.nearMissDrama.timeScale, CONFIG.nearMissDrama.duration);
        target.dashCooldown = 0;
        target.nearMissCooldown = CONFIG.nearMissDrama.cooldown;

        // Extra trail to highlight the near-miss bullet.
        spawnTracer(start, end, COLORS.near, CONFIG.nearMissDrama.duration);
        
        // Play near miss sound and track stats
        if (target.isPlayer) {
          AudioManager.playNearMiss();
          if (target.matchStats) target.matchStats.nearMisses = (target.matchStats.nearMisses || 0) + 1;
        }

        const popupPos = target.position.clone();
        popupPos.y = 1.9;
        spawnPopup('CLOSE!', popupPos, 'close', 0.6);
      }
    }

    function endRound(winner, timeExpired) {
      if (state.gameMode === 'deathmatch') return;
      if (state.roundEnding || state.matchEnded) return;
      state.roundEnding = true;
      state.suddenDeath = false;
      suddenDeathEl.classList.remove('show');

      if (winner === 'p1') state.wins.p1 += 1;
      if (winner === 'p2') state.wins.p2 += 1;
      state.roundResults.push(winner);
      updateRoundPips();

      const matchWillEnd = !timeExpired && (state.wins[winner] >= CONFIG.match.roundsToWin);
      if (matchWillEnd && state.lastKill) {
        triggerKillCam(winner);
        return;
      }

      setTimeScale(0.8, 0.35);
      showBanner(winner === 'p1' ? 'PLAYER 1 WINS ROUND' : 'PLAYER 2 WINS ROUND');

      setTimeout(() => {
        state.roundEnding = false;
        if (state.wins.p1 >= CONFIG.match.roundsToWin || state.wins.p2 >= CONFIG.match.roundsToWin || timeExpired) {
          endMatch(winner);
        } else {
          state.round += 1;
	          resetEntities();
	          resetBarrels();
	          resetCover();
	          clearPickups();
	          clearGrenades();
	          setMode('roundIntro');
	          showBanner(`ROUND ${state.round} · FIGHT!`);
          setTimeout(() => {
            if (state.mode === 'roundIntro') setMode('playing');
          }, 1000);
        }
      }, 1200);
    }

    function triggerKillCam(winnerTeam) {
      const last = state.lastKill;
      if (!last) {
        endMatch(winnerTeam);
        return;
      }

      // Clear transient FX so the cinematic reads cleanly.
      fx.timeScale = 1;
      fx.timeScaleTimer = 0;
      fx.hitstopTimer = 0;
      fx.nearMissTimer = 0;
      fx.dramaticTimer = 0;
      fx.dramaticTeam = null;
      killCamTextEl.classList.remove('show');

      const shooter = last.shooterPos.clone();
      const victim = last.victimPos.clone();
      const center = shooter.clone().add(victim).multiplyScalar(0.5);
      center.y = 0.8;
      const distance = Math.max(3, shooter.distanceTo(victim));
      const radius = distance / 2 + 3;

      const startAngle = Math.atan2(shooter.x - center.x, shooter.z - center.z);

      state.killCam = {
        active: true,
        winnerTeam,
        shooter,
        victim,
        center,
        radius,
        startAngle,
        orbitAngle: startAngle,
        startCamPos: world.camera.position.clone(),
        startCamLookAt: world.cameraState?.lookAt?.clone?.() || center.clone(),
        startCamFov: world.camera.fov,
        phase: 'freeze',
        timer: 0,
        didImpactFx: false,
        timeScale: 0
      };

      setMode('killCam');
    }

    function updateKillCam(dt) {
      const kc = state.killCam;
      if (!kc || !kc.active) return;

      const freezeDur = 0.3;
      const orbitDur = 1.5;
      const impactDur = 0.5;
      const slamDur = 0.3;
      const holdDur = 0.5;

      kc.timer += dt;

      if (kc.phase === 'freeze') {
        kc.timeScale = 0;
        world.camera.position.copy(kc.startCamPos);
        world.camera.fov = kc.startCamFov;
        world.camera.updateProjectionMatrix();
        world.camera.lookAt(kc.startCamLookAt);
        if (kc.timer >= freezeDur) {
          kc.phase = 'orbit';
          kc.timer = 0;
          kc.timeScale = 0.2;
        }
      } else if (kc.phase === 'orbit') {
        kc.timeScale = 0.2;
        const t = THREE.MathUtils.clamp(kc.timer / orbitDur, 0, 1);
        kc.orbitAngle = kc.startAngle + Math.PI * t;
        if (kc.timer >= orbitDur) {
          kc.phase = 'impact';
          kc.timer = 0;
        }
      } else if (kc.phase === 'impact') {
        kc.timeScale = 0.2;
        if (!kc.didImpactFx) {
          kc.didImpactFx = true;
          spawnHitEffect(kc.victim, kc.winnerTeam === 'p1' ? 'p2' : 'p1', true);
          fx.shakeTime = 0.22;
          fx.shakeIntensity = 0.5;
        }
        if (kc.timer >= impactDur) {
          kc.phase = 'slam';
          kc.timer = 0;
          killCamTextEl.classList.add('show');
        }
      } else if (kc.phase === 'slam') {
        kc.timeScale = 0.05;
        if (kc.timer >= slamDur) {
          kc.phase = 'hold';
          kc.timer = 0;
        }
      } else if (kc.phase === 'hold') {
        kc.timeScale = 0.02;
        if (kc.timer >= holdDur) {
          killCamTextEl.classList.remove('show');
          state.killCam = null;
          endMatch(kc.winnerTeam);
          return;
        }
      }

      if (kc.phase !== 'freeze') {
        // Camera orbit math (handled separately from the normal dynamic camera).
        const phaseT = kc.phase === 'orbit' ? THREE.MathUtils.clamp(kc.timer / orbitDur, 0, 1) : 1;
        const height = 4.8 + Math.sin(phaseT * Math.PI) * 2.2 - phaseT * 1.2;
        const camPos = new THREE.Vector3(
          kc.center.x + Math.sin(kc.orbitAngle) * kc.radius,
          kc.center.y + height,
          kc.center.z + Math.cos(kc.orbitAngle) * kc.radius
        );
        world.camera.position.copy(camPos);
        world.camera.fov = 45;
        world.camera.updateProjectionMatrix();
        world.camera.lookAt(kc.center);
      }

      updatePopups(dt);
    }

    function endMatch(winner) {
      state.matchEnded = true;
      state.suddenDeath = false;
      suddenDeathEl.classList.remove('show');
      setMode('matchOver');
      const elapsed = CONFIG.match.totalTime - state.timeLeft;
      if (!winner) {
        matchTitle.textContent = 'MATCH OVER';
      } else {
        const winnerEntity = getEntityByTeam(winner);
        const winnerLabel = winnerEntity?.displayName || (winner === 'p1' ? 'Player 1' : winner === 'p2' ? 'Player 2' : 'Player');
        matchTitle.textContent = `${winnerLabel.toUpperCase()} WINS!`;
      }
      matchStats.textContent = `Match time: ${formatTime(elapsed)}`;

      if (state.gameMode === 'duel' && winner === 'p1') {
        if (state.bestWinTime === null || elapsed < state.bestWinTime) {
          state.bestWinTime = elapsed;
          localStorage.setItem('tinyToonDuel_bestWinSeconds', String(elapsed));
        }
      }
      updateBestTimeUI();
      
      // Check achievements and record stats
      const player = getPlayer();
      if (player && winner === 'p1') {
        // Calculate accuracy
        const stats = player.matchStats || {};
        const accuracy = stats.shotsFired > 0 ? (stats.shotsHit / stats.shotsFired) * 100 : 0;
        
        // Record match in persistent stats
        PlayerStats.recordMatch(true, accuracy);
        
        // Check achievements
        if (PlayerStats.unlockAchievement('first_blood')) {
          spawnAchievementPopup('first_blood');
        }
        if (elapsed < 30 && PlayerStats.unlockAchievement('speedrunner')) {
          spawnAchievementPopup('speedrunner');
        }
        if (state.gameMode === 'duel' && state.wins.p1 >= 3 && state.wins.p2 === 0) {
          if (PlayerStats.unlockAchievement('domination')) {
            spawnAchievementPopup('domination');
          }
        }
        if (player.hp > 0 && player.hp <= 10 && PlayerStats.unlockAchievement('survivor')) {
          spawnAchievementPopup('survivor');
        }
        if (accuracy >= 80 && stats.shotsFired >= 10 && PlayerStats.unlockAchievement('sharpshooter')) {
          spawnAchievementPopup('sharpshooter');
        }
        if ((stats.nearMisses || 0) >= 5 && PlayerStats.unlockAchievement('close_call')) {
          spawnAchievementPopup('close_call');
        }
      } else if (player) {
        PlayerStats.recordMatch(false, 0);
      }
      
      // Submit score to Hub
      submitScoreToHub(winner, elapsed);
    }
    
    // Submit score to the Hub via postMessage
    function submitScoreToHub(winner, matchTime) {
      if (window.parent && window.parent !== window) {
        // Calculate score based on: wins, match time, and player performance
        // Player wins = 1000 pts, faster wins = bonus points (max 500)
        const didWin = winner === 'p1';
        const baseScore = didWin ? 1000 : 100;
        const timeBonus = didWin ? Math.max(0, Math.floor((CONFIG.match.totalTime - matchTime) * 5)) : 0;
        const winsBonus = state.wins.p1 * 200;
        const score = baseScore + timeBonus + winsBonus;
        
        window.parent.postMessage({
          type: 'SUBMIT_SCORE',
          payload: {
            gameId: 'toonshooter',
            score: score,
            completed: didWin
          }
        }, '*');
        console.log('[ToonShooter] Score submitted to Hub:', score, didWin ? '(WIN)' : '(LOSS)');
      }
    }

    function togglePause() {
      if (state.mode !== 'playing' && state.mode !== 'paused') return;
      if (state.mode === 'playing') {
        setMode('paused');
        bannerEl.textContent = 'PAUSED';
        bannerEl.classList.add('show');
      } else if (state.mode === 'paused') {
        bannerEl.classList.remove('show');
        setMode('playing');
      }
    }

    function updateMuzzleFlash(entity, dt) {
      if (!entity.muzzle) return;
      if (entity.muzzle.visible) {
        entity.muzzle.life -= dt;
        if (entity.muzzle.life <= 0) entity.muzzle.visible = false;
      }
    }

    function updateHUD() {
      const showLives = state.gameMode === 'deathmatch';
      world.entities.forEach((entity) => {
        const panel = hudPanels.get(entity.id);
        if (!panel) return;
        updateHpBar(panel.hpBar, entity.hp, entity.team);
        updateWeaponDisplay(panel, entity);
        
        // Update Shield
        if (panel.shieldFill) {
          const shieldPct = Math.min(100, (entity.shield || 0) * 2); // Max shield 50 -> 100%
          panel.shieldFill.style.width = `${shieldPct}%`;
        }
        
        // Update Stats
        if (panel.kills && entity.matchStats) {
          panel.kills.textContent = `K: ${entity.matchStats.kills || 0}`;
          panel.deaths.textContent = `D: ${entity.matchStats.deaths || 0}`;
        }
        
        // Update Buffs
        if (panel.buffRow) {
          panel.buffRow.innerHTML = '';
          if (entity.buffs?.speedTimer > 0) {
            const icon = document.createElement('div');
            icon.className = 'buffIcon speed';
            icon.textContent = `SPD ${Math.ceil(entity.buffs.speedTimer)}`;
            panel.buffRow.appendChild(icon);
          }
          if (entity.buffs?.damageTimer > 0) {
            const icon = document.createElement('div');
            icon.className = 'buffIcon damage';
            icon.textContent = `DMG ${Math.ceil(entity.buffs.damageTimer)}`;
            panel.buffRow.appendChild(icon);
          }
        }
        
        if (panel.livesInfo) {
          panel.livesInfo.style.display = showLives ? 'block' : 'none';
          panel.livesInfo.textContent = `Lives: ${Math.max(0, entity.lives ?? 0)}`;
        }
        panel.panel.classList.toggle('down', entity.isDead || entity.eliminated);
      });
      timerEl.textContent = `TIME: ${formatTime(state.timeLeft)}`;
      timerEl.classList.toggle('low', state.timeLeft <= 30);
      const player = getPlayer();
      const cooldownPct = player
        ? THREE.MathUtils.clamp(player.dashCooldown / CONFIG.movement.dashCooldown, 0, 1)
        : 0;
      dashCooldownEl.style.width = `${cooldownPct * 100}%`;
      updateLeaderboard();
    }

    function updateLeaderboard() {
      if (!leaderboardOverlay || !leaderboardList) return;
      const shouldShow = state.showLeaderboard && state.gameMode === 'deathmatch' && state.mode === 'playing';
      leaderboardOverlay.classList.toggle('visible', shouldShow);
      if (!shouldShow) return;

      leaderboardList.innerHTML = '';
      const sorted = [...world.entities].sort((a, b) => {
        const livesDiff = (b.lives ?? 0) - (a.lives ?? 0);
        if (livesDiff !== 0) return livesDiff;
        return (b.hp ?? 0) - (a.hp ?? 0);
      });
      sorted.forEach((entity) => {
        const row = document.createElement('div');
        row.className = 'leaderboardRow';
        const label = document.createElement('div');
        label.className = 'label';
        const badge = document.createElement('span');
        badge.className = 'leaderboardBadge';
        badge.style.background = `#${getTeamColor(entity.team).toString(16).padStart(6, '0')}`;
        const name = document.createElement('span');
        name.textContent = entity.displayName || entity.id;
        label.append(badge, name);
        const lives = document.createElement('span');
        lives.textContent = `Lives: ${Math.max(0, entity.lives ?? 0)}`;
        row.append(label, lives);
        leaderboardList.appendChild(row);
      });
    }

    function updateWeaponDisplay(panel, entity) {
      const isSwitching = entity.weapon.switchTimer > 0 && entity.weapon.pending;
      const activeId = isSwitching ? entity.weapon.pending : entity.weapon.id;
      const weapon = getWeaponConfig(activeId);
      const state = getWeaponState(entity, activeId);
      if (!weapon || !state) return;

      panel.weaponIcon.textContent = weapon.name[0];
      panel.weaponName.textContent = weapon.name;
      if (isSwitching) {
        panel.weaponAmmo.textContent = 'Switching';
        panel.weaponReserve.textContent = '';
      } else {
        panel.weaponAmmo.textContent = `${state.ammo}/${weapon.magSize}`;
        panel.weaponReserve.textContent = `[${state.reserve}]`;
      }
      panel.weaponInfo.classList.toggle('reloading', !isSwitching && state.reloadTimer > 0);
      panel.weaponInfo.classList.toggle('switching', isSwitching);
    }

    function updateHpBar(container, hp, team) {
      const segments = container.querySelectorAll('.hpSeg');
      const activeCount = Math.ceil(hp / 10);
      segments.forEach((seg, index) => {
        seg.classList.toggle('active', index < activeCount);
        seg.classList.toggle(team, index < activeCount);
      });
    }

    function updateRoundPips() {
      if (state.gameMode === 'deathmatch') {
        roundPipsEl.style.opacity = '0';
        return;
      }
      roundPipsEl.style.opacity = '1';
      const pips = roundPipsEl.querySelectorAll('.pip');
      pips.forEach((pip, index) => {
        pip.classList.remove('p1', 'p2');
        if (state.roundResults[index] === 'p1') pip.classList.add('p1');
        if (state.roundResults[index] === 'p2') pip.classList.add('p2');
      });
    }

    function showBanner(text) {
      bannerEl.textContent = text;
      bannerEl.classList.add('show');
      setTimeout(() => bannerEl.classList.remove('show'), 1000);
    }

    function spawnPopup(text, worldPos, kind = 'close', duration = 0.6) {
      if (!popupsEl) return;
      const el = document.createElement('div');
      el.className = `popup ${kind}`;
      el.textContent = text;
      popupsEl.appendChild(el);
      world.popups.push({
        el,
        pos: worldPos.clone(),
        life: duration,
        maxLife: duration
      });
    }

    function spawnDamageNumber(amount, worldPos, isCrit = false) {
      if (!popupsEl) return;
      const el = document.createElement('div');
      el.className = 'damage-number' + (isCrit ? ' crit' : '');
      el.textContent = amount;
      popupsEl.appendChild(el);
      world.popups.push({
        el,
        pos: worldPos.clone(),
        life: 0.6,
        maxLife: 0.6,
        isDamageNumber: true
      });
    }

    function spawnAchievementPopup(achievementId) {
      const ach = ACHIEVEMENTS[achievementId];
      if (!ach) return;
      AudioManager.playAchievement();
      const popup = document.createElement('div');
      popup.className = 'achievement-popup';
      popup.innerHTML = `
        <div class="achievement-icon">${ICONS.trophy}</div>
        <div class="achievement-text">
          <div class="achievement-title">ACHIEVEMENT UNLOCKED</div>
          <div class="achievement-name">${ach.name}</div>
          <div class="achievement-desc">${ach.desc}</div>
        </div>
      `;
      document.body.appendChild(popup);
      setTimeout(() => popup.classList.add('show'), 50);
      setTimeout(() => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 500);
      }, 3000);
    }

    function updatePopups(dt) {
      if (!popupsEl) return;
      const rect = canvasWrap.getBoundingClientRect();
      world.popups = world.popups.filter((popup) => {
        popup.life -= dt;
        const t = 1 - THREE.MathUtils.clamp(popup.life / popup.maxLife, 0, 1);

        const projected = popup.pos.clone().project(world.camera);
        const x = (projected.x * 0.5 + 0.5) * rect.width;
        const y = (-projected.y * 0.5 + 0.5) * rect.height;

        popup.el.style.left = `${x}px`;
        popup.el.style.top = `${y - t * 26}px`;
        popup.el.style.opacity = String(1 - t);

        if (popup.life <= 0) {
          popup.el.remove();
          return false;
        }
        return true;
      });
    }

    function setTimeScale(scale, duration) {
      fx.timeScale = scale;
      fx.timeScaleTimer = duration;
    }

    function triggerRecoil() {
      fx.fovPulse = 0.6;
    }

    function triggerShootAnimation(entity) {
      const mixerEntry = entity.mixers;
      if (!mixerEntry || !mixerEntry.actions.shoot) return;
      const action = mixerEntry.actions.shoot;
      action.reset();
      action.play();
    }

    function triggerMuzzle(attacker, dir, weapon = null) {
      if (!attacker.muzzle) return;
      // Position muzzle flash at the gun tip in WORLD space
      // Gun is held to the right side, so offset sideways + forward in facing direction
      const forward = dir.clone().normalize();
      const right = new THREE.Vector3(-forward.z, 0, forward.x); // perpendicular
      // Muzzle is ~0.9 units forward + 0.25 units to right side (gun hand)
      const muzzlePos = attacker.position.clone();
      muzzlePos.y = 1.05;
      muzzlePos.addScaledVector(forward, 0.9);
      muzzlePos.addScaledVector(right, 0.25);
      attacker.muzzle.position.copy(muzzlePos);
      const size = weapon?.muzzleSize ?? 0.3;
      attacker.muzzle.scale.set(size, size, size);
      attacker.muzzle.visible = true;
      attacker.muzzle.life = weapon?.pellets ? 0.08 : 0.06;
    }

    function spawnTracer(start, end, color = COLORS.tracer, life = 0.05, options = null) {
      const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
      const opacity = options?.opacity ?? 1;
      const additive = options?.additive ?? false;
      const material = new THREE.LineBasicMaterial({
        color,
        transparent: opacity < 1 || additive,
        opacity,
        blending: additive ? THREE.AdditiveBlending : THREE.NormalBlending,
        depthWrite: false
      });
      const line = new THREE.Line(geometry, material);
      line.userData.life = life;
      line.renderOrder = additive ? 10 : 0;
      world.scene.add(line);
      world.fxLines.push(line);
    }

    function updateTracers(dt) {
      world.fxLines = world.fxLines.filter((line) => {
        line.userData.life -= dt;
        if (line.userData.life <= 0) {
          world.scene.remove(line);
          line.geometry.dispose();
          line.material.dispose();
          return false;
        }
        return true;
      });
    }

    function createSprite(color, size) {
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(16, 16, 10, 0, Math.PI * 2);
      ctx.fill();
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ color, map: texture, transparent: true, opacity: 0.9 });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(size, size, size);
      return sprite;
    }

    function spawnExplosion(position) {
      const smoke = createSprite(0x666666, 2.4);
      smoke.position.copy(position.clone().add(new THREE.Vector3(0, 1.2, 0)));
      smoke.userData.life = 0.4;
      world.scene.add(smoke);
      world.fxSprites.push(smoke);
    }

    function updateSprites(dt) {
      world.fxSprites = world.fxSprites.filter((sprite) => {
        sprite.userData.life -= dt;
        sprite.material.opacity = Math.max(0, sprite.userData.life / 0.4);
        sprite.scale.multiplyScalar(1 + dt * 1.5);
        if (sprite.userData.life <= 0) {
          world.scene.remove(sprite);
          sprite.material.map.dispose();
          sprite.material.dispose();
          return false;
        }
        return true;
      });
    }

    function updateParticles(dt) {
      const gravity = -15;
      world.fxParticles = world.fxParticles.filter((particle) => {
        particle.userData.life -= dt;
        // Apply gravity
        particle.userData.velocity.y += gravity * dt;
        // Move particle
        particle.position.addScaledVector(particle.userData.velocity, dt);
        // Bounce off ground
        if (particle.position.y < 0.05) {
          particle.position.y = 0.05;
          particle.userData.velocity.y *= -0.3;
          particle.userData.velocity.x *= 0.7;
          particle.userData.velocity.z *= 0.7;
        }
        // Fade out
        const lifeRatio = particle.userData.life / particle.userData.maxLife;
        particle.material.opacity = lifeRatio * 0.9;

        if (particle.userData.life <= 0) {
          world.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          return false;
        }
        return true;
      });
    }

    function updateMixers(dt) {
      if (state.mode === 'paused' || fx.hitstopTimer > 0) return;
      world.mixers.forEach((entry) => {
        entry.mixer.update(dt);
      });
    }

    function updateAnimationState(entity, stateName) {
      const mixerEntry = entity.mixers;
      if (!mixerEntry) return;
      // Don't interrupt death animation
      if (mixerEntry.current === 'death') return;
      if (entity.isDead) return;
      const weaponState = entity.weapon ? getWeaponState(entity) : null;
      const isReloading = weaponState && weaponState.reloadTimer > 0 && mixerEntry.actions.reload;
      if (isReloading && stateName !== 'reload') return;
      const isStunned = entity.stunTimer > 0 && mixerEntry.actions.hit;
      if (isStunned && stateName !== 'hit') return;
      if (mixerEntry.current === stateName) return;
      const next = mixerEntry.actions[stateName];
      if (!next) return;
      const current = mixerEntry.actions[mixerEntry.current];
      if (current) current.fadeOut(0.15);
      next.reset();
      next.fadeIn(0.15);
      next.play();
      mixerEntry.current = stateName;
    }

    function updateCameraFx(dt) {
      if (state.mode === 'killCam') return;
      if (!world.cameraState) {
        world.cameraState = {
          pos: CONFIG.camera.position.clone(),
          lookAt: CONFIG.camera.lookAt.clone(),
          fov: CONFIG.camera.fov
        };
      }

      const player = getPlayer();
      const alive = getAliveEntities();
      const center = alive.length
        ? alive.reduce((acc, entity) => acc.add(entity.position), new THREE.Vector3()).multiplyScalar(1 / alive.length)
        : CONFIG.camera.lookAt.clone();
      center.y = 0;

      let targetPos = CONFIG.camera.position.clone();
      let targetLookAt = center.clone();
      let targetFov = CONFIG.camera.fov;

      // Follow the fight slightly so the action stays centered.
      targetPos.x += center.x * 0.12;
      targetPos.z += center.z * 0.08;

      const bothFiring = alive.filter(entity => entity.firedRecentlyTimer > 0).length >= 2;
      if (bothFiring) {
        targetFov += 5;
        targetPos.y += 2;
      }

      if (player && player.hp <= 35) {
        targetFov -= 2;
        const t = THREE.MathUtils.clamp((35 - player.hp) / 35, 0, 1);
        lowHpVignette.style.opacity = String(0.75 * t);
      } else {
        lowHpVignette.style.opacity = '0';
      }

      if (fx.dramaticTimer > 0 && fx.dramaticTeam) {
        const dodger = getEntityByTeam(fx.dramaticTeam);
        if (dodger) {
          targetFov = CONFIG.camera.fov / CONFIG.nearMissDrama.cameraZoom;
          targetLookAt = dodger.position.clone();
          targetLookAt.y = 0.7;
          targetPos.x += (dodger.position.x - center.x) * 0.8;
          targetPos.z += (dodger.position.z - center.z) * 0.6;
        }
      }

      const lerpK = 1 - Math.exp(-dt * 3);
      world.cameraState.pos.lerp(targetPos, lerpK);
      world.cameraState.lookAt.lerp(targetLookAt, lerpK);
      world.cameraState.fov = THREE.MathUtils.lerp(world.cameraState.fov, targetFov, lerpK);

      const shake = fx.shakeTime > 0 ? fx.shakeIntensity : 0;
      if (fx.shakeTime > 0) fx.shakeTime -= dt;
      const shakeOffset = new THREE.Vector3(
        (Math.random() - 0.5) * shake,
        (Math.random() - 0.5) * shake,
        (Math.random() - 0.5) * shake
      );

      fx.fovPulse = moveToward(fx.fovPulse, 0, dt * 5);
      world.camera.fov = world.cameraState.fov + fx.fovPulse * 2;
      world.camera.updateProjectionMatrix();
      world.camera.position.copy(world.cameraState.pos).add(shakeOffset);
      world.camera.lookAt(world.cameraState.lookAt);
    }

    function tryDash(entity, aiInitiated = false) {
      if (entity.dashCooldown > 0 || entity.dashTimer > 0) {
        if (!aiInitiated) {
          dashEl.classList.remove('shake');
          void dashEl.offsetWidth;
          dashEl.classList.add('shake');
        }
        return;
      }
      const dir = getDashDirection(entity);
      entity.velocity.copy(dir).multiplyScalar(CONFIG.movement.dashSpeed);
      entity.dashTimer = CONFIG.movement.dashDuration;
      entity.dashCooldown = CONFIG.movement.dashCooldown;
      fx.fovPulse = 1;
      
      // Play dash sound for player
      if (entity.isPlayer) AudioManager.playDash();
    }

    function getDashDirection(entity) {
      const moveDir = entity.isAI ? (entity.ai.desiredMove || new THREE.Vector3()) : getMoveInput();
      if (moveDir.lengthSq() > 0.01) return moveDir.clone().normalize();
      const aim = getAimDirection(entity, entity.isAI ? getPlayer().position : null);
      return aim.lengthSq() > 0 ? aim : new THREE.Vector3(0, 0, 1);
    }

	    function tryThrowGrenade(entity, aiInitiated = false) {
	      if (!entity || entity.isDead || entity.eliminated) return;
	      if (entity.stunTimer > 0) return;
	      if (entity.weapon?.switchTimer > 0) return;
	      if ((entity.grenadeAmmo ?? 0) <= 0) return;
	      if ((entity.grenadeCooldown ?? 0) > 0) return;

	      const aimPoint = entity.isAI ? getAITarget(entity)?.position : getAimPoint();
	      const dir = getAimDirection(entity, aimPoint);
	      const forward = dir.clone().normalize();
	      const right = new THREE.Vector3(-forward.z, 0, forward.x);

	      const origin = entity.position.clone();
	      origin.y = 1.22;
	      origin.addScaledVector(forward, 0.55);
	      origin.addScaledVector(right, 0.18);

	      const velocity = forward.multiplyScalar(CONFIG.grenade.throwSpeed);
	      if (aimPoint) {
	        const dx = aimPoint.x - entity.position.x;
	        const dz = aimPoint.z - entity.position.z;
	        const dist = Math.hypot(dx, dz);
	        velocity.y = CONFIG.grenade.throwUp + THREE.MathUtils.clamp(dist * 0.16, 0, 2.8);
	      } else {
	        velocity.y = CONFIG.grenade.throwUp;
	      }
	      velocity.x += entity.velocity.x * 0.35;
	      velocity.z += entity.velocity.z * 0.35;

      spawnGrenade(origin, velocity, entity.team);
      entity.grenadeAmmo = Math.max(0, (entity.grenadeAmmo ?? 0) - 1);
      entity.grenadeCooldown = CONFIG.grenade.cooldown;
      if (!aiInitiated) fx.fovPulse = Math.max(fx.fovPulse, 0.45);
      
      // Play grenade throw sound and track stats
      if (entity.isPlayer) {
        AudioManager.playGrenade();
        if (entity.matchStats) entity.matchStats.grenadesThrown++;
      }
    }

    function spawnGrenade(position, velocity, sourceTeam) {
      const { mesh, activeVisual } = createGrenadeMesh();
      mesh.position.copy(position);
      mesh.rotation.y = Math.random() * Math.PI * 2;
      world.scene.add(mesh);

      const grenade = {
        mesh,
        position: mesh.position,
        velocity: velocity.clone(),
        radius: CONFIG.grenade.radius,
        fuse: CONFIG.grenade.fuse,
        sourceTeam,
        visuals: (() => {
          const visuals = { gltf: null, placeholder: null };
          visuals[activeVisual] = mesh;
          return visuals;
        })(),
        activeVisual
      };
      world.grenades.push(grenade);
      return grenade;
    }

    function tryKick(entity, aiInitiated = false) {
      if (!entity || entity.isDead) return;
      if (entity.stunTimer > 0) return;
      if (entity.kickCooldown > 0) return;
      if (entity.weapon.switchTimer > 0) return;

      const kickable = getNearbyKickable(entity);
      if (!kickable) return;

      const dir = getAimDirection(entity, entity.isAI ? getPlayer().position : null);
      if (kickable.type === 'barrel') {
        kickBarrel(kickable.object, dir, entity.team);
      } else if (kickable.type === 'cover') {
        kickCover(kickable.object, dir, entity.team);
      }

      entity.kickCooldown = CONFIG.kick.cooldown;
      if (!aiInitiated) fx.fovPulse = Math.max(fx.fovPulse, 0.65);
    }

    function getNearbyKickable(entity) {
      const kickRange = CONFIG.kick.range;
      for (const barrel of world.barrels) {
        if (!barrel.alive) continue;
        if (barrel.isRolling) continue;
        if (barrel.position.distanceTo(entity.position) < kickRange) {
          return { type: 'barrel', object: barrel };
        }
      }
      for (const cover of world.cover) {
        if (cover.active === false) continue;
        if (!cover.kickable) continue;
        if (!cover.destructible) continue;
        if (!cover.mesh || cover.mesh.visible === false) continue;
        if (distToAABB(entity.position, cover) < kickRange) {
          return { type: 'cover', object: cover };
        }
      }
      return null;
    }

    function distToAABB(pos, box) {
      const clampedX = THREE.MathUtils.clamp(pos.x, box.minX, box.maxX);
      const clampedZ = THREE.MathUtils.clamp(pos.z, box.minZ, box.maxZ);
      return Math.hypot(pos.x - clampedX, pos.z - clampedZ);
    }

    function kickBarrel(barrel, direction, sourceTeam) {
      if (!barrel.alive) return;
      barrel.isRolling = true;
      barrel.velocity.copy(direction).multiplyScalar(CONFIG.kick.barrelRollSpeed);
      barrel.rollTimer = CONFIG.kick.barrelRollTime;
      barrel.lastDamagedByTeam = sourceTeam;
    }

    function kickCover(cover, direction, sourceTeam) {
      if (!cover || cover.active === false) return;
      if (!cover.destructible) return;
      if (cover.kickState) return;
      cover.kickState = {
        velocity: direction.clone().multiplyScalar(CONFIG.kick.coverSlideSpeed),
        timer: CONFIG.kick.coverSlideDuration,
        sourceTeam
      };
      flashCover(cover, 0.06);
    }

    function resolveCircleAABB(pos, radius, box) {
      const clampedX = THREE.MathUtils.clamp(pos.x, box.minX, box.maxX);
      const clampedZ = THREE.MathUtils.clamp(pos.z, box.minZ, box.maxZ);
      const dx = pos.x - clampedX;
      const dz = pos.z - clampedZ;
      const distSq = dx * dx + dz * dz;
      if (distSq < radius * radius) {
        const dist = Math.sqrt(distSq) || 0.0001;
        const push = radius - dist;
        pos.x += (dx / dist) * push;
        pos.z += (dz / dist) * push;
      }
    }

    function resolveCircleCircle(pos, radius, center, otherRadius) {
      const dx = pos.x - center.x;
      const dz = pos.z - center.z;
      const distSq = dx * dx + dz * dz;
      const minDist = radius + otherRadius;
      if (distSq < minDist * minDist) {
        const dist = Math.sqrt(distSq) || 0.0001;
        const push = minDist - dist;
        pos.x += (dx / dist) * push;
        pos.z += (dz / dist) * push;
      }
    }

    function findCoverHit(start, end) {
      let result = null;
      world.cover.forEach((cover) => {
        if (cover.active === false) return;
        const t = segmentAABB(start, end, cover);
        if (t !== null && (!result || t < result.t)) result = { cover, t };
      });
      return result;
    }

    function findClosestPlayerHit(start, end, attacker) {
      let result = null;
      world.entities.forEach((entity) => {
        if (!entity || entity === attacker || entity.isDead || entity.eliminated) return;
        const t = segmentCircle(start, end, entity.position, CONFIG.player.hurtRadius);
        if (t !== null && (!result || t < result.t)) {
          result = { entity, t };
        }
      });
      return result;
    }

    function findClosestMiss(start, end, attacker) {
      let best = null;
      let bestDist = Infinity;
      world.entities.forEach((entity) => {
        if (!entity || entity === attacker || entity.isDead || entity.eliminated) return;
        const dist = distancePointToSegmentXZ(entity.position, start, end);
        if (dist < bestDist) {
          bestDist = dist;
          best = { entity, dist };
        }
      });
      return best;
    }

    function findCircleHit(start, end, center, radius) {
      return segmentCircle(start, end, center, radius);
    }

    function findBarrelHit(start, end) {
      let result = null;
      world.barrels.forEach((barrel) => {
        if (!barrel.alive) return;
        const t = segmentCircle(start, end, barrel.position, barrel.radius);
        if (t !== null && (!result || t < result.t)) {
          result = { barrel, t };
        }
      });
      return result;
    }

    function segmentAABB(p0, p1, box) {
      let tmin = 0;
      let tmax = 1;
      const dx = p1.x - p0.x;
      const dz = p1.z - p0.z;
      if (!updateSlab(p0.x, dx, box.minX, box.maxX)) return null;
      if (!updateSlab(p0.z, dz, box.minZ, box.maxZ)) return null;
      function updateSlab(p, d, min, max) {
        if (Math.abs(d) < 1e-6) {
          return p >= min && p <= max;
        }
        const inv = 1 / d;
        let t1 = (min - p) * inv;
        let t2 = (max - p) * inv;
        if (t1 > t2) [t1, t2] = [t2, t1];
        tmin = Math.max(tmin, t1);
        tmax = Math.min(tmax, t2);
        return tmin <= tmax;
      }
      if (tmin < 0 || tmin > 1) return null;
      return tmin;
    }

    function segmentCircle(p0, p1, center, radius) {
      const dx = p1.x - p0.x;
      const dz = p1.z - p0.z;
      const fx = p0.x - center.x;
      const fz = p0.z - center.z;
      const a = dx * dx + dz * dz;
      const b = 2 * (fx * dx + fz * dz);
      const c = fx * fx + fz * fz - radius * radius;
      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) return null;
      const sqrt = Math.sqrt(discriminant);
      const t1 = (-b - sqrt) / (2 * a);
      const t2 = (-b + sqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) return t1;
      if (t2 >= 0 && t2 <= 1) return t2;
      return null;
    }

    function distancePointToSegmentXZ(point, start, end) {
      const px = point.x;
      const pz = point.z;
      const sx = start.x;
      const sz = start.z;
      const ex = end.x;
      const ez = end.z;
      const dx = ex - sx;
      const dz = ez - sz;
      const lenSq = dx * dx + dz * dz;
      if (lenSq === 0) return Math.hypot(px - sx, pz - sz);
      let t = ((px - sx) * dx + (pz - sz) * dz) / lenSq;
      t = THREE.MathUtils.clamp(t, 0, 1);
      const cx = sx + t * dx;
      const cz = sz + t * dz;
      return Math.hypot(px - cx, pz - cz);
    }

    function hasLineOfSight(a, b) {
      for (const box of world.cover) {
        if (box.active === false) continue;
        if (segmentAABB(a, b, box) !== null) return false;
      }
      for (const barrel of world.barrels) {
        if (!barrel.alive) continue;
        if (segmentCircle(a, b, barrel.position, barrel.radius) !== null) return false;
      }
      return true;
    }

    function getSimTimeScale() {
      if (state.mode === 'paused') return 0;
      if (state.mode === 'killCam' && state.killCam?.active) return state.killCam.timeScale;
      return fx.timeScale;
    }

    function moveToward(current, target, maxDelta) {
      if (Math.abs(target - current) <= maxDelta) return target;
      return current + Math.sign(target - current) * maxDelta;
    }

    function rotateToward(current, target, maxDelta) {
      const diff = THREE.MathUtils.euclideanModulo(target - current + Math.PI, Math.PI * 2) - Math.PI;
      if (Math.abs(diff) <= maxDelta) return target;
      return current + Math.sign(diff) * maxDelta;
    }

    function formatTime(seconds) {
      if (seconds === null || Number.isNaN(seconds)) return '--';
      const total = Math.max(0, Math.floor(seconds));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    function getPlayer() {
      return world.entities.find((entity) => entity.isPlayer) || world.entities.find((entity) => entity.team === 'p1');
    }

    function getEnemy() {
      return world.entities.find((entity) => entity.team === 'p2');
    }

    function getEntityByTeam(team) {
      return world.entities.find((entity) => entity.team === team);
    }

    function getAliveEntities() {
      return world.entities.filter((entity) => entity && !entity.isDead && !entity.eliminated);
    }

    function getFallbackOpponentTeam(team) {
      const opponent = world.entities.find((entity) => entity.team !== team && !entity.eliminated);
      return opponent ? opponent.team : team;
    }

    function getTeamColor(team) {
      if (team === 'p1') return COLORS.p1;
      if (team === 'p2') return COLORS.p2;
      if (team === 'p3') return COLORS.p3;
      if (team === 'p4') return COLORS.p4;
      return COLORS.warning;
    }
    function createReticle() {
      world.reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.18, 0.24, 28),
        new THREE.MeshBasicMaterial({ color: COLORS.near, transparent: true, opacity: 0.6 })
      );
      world.reticle.rotation.x = -Math.PI / 2;
      world.reticle.position.set(0, 0.02, 0);
      world.scene.add(world.reticle);
    }
  </script>
    <!-- Arcade Hub Integration -->
    <script src="/games/game-bridge.js"></script>
    <script>
        if (window.ArcadeHub) {
            ArcadeHub.notifyReady();
        }
    </script>
</body>
</html>
